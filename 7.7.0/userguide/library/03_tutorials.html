
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>9. OpenMM Tutorials &#8212; OpenMM User Guide 7.7 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="10. Platform-Specific Properties" href="04_platform_specifics.html" />
    <link rel="prev" title="8. Compiling OpenMM from Source Code" href="02_compiling.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  <script>var script = document.createElement("script"); script.type = "text/javascript"; script.src = "/versionwarning.js"; document.head.appendChild(script);</script>
</head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="openmm-tutorials">
<span id="id1"></span><h1><span class="section-number">9. </span>OpenMM Tutorials<a class="headerlink" href="03_tutorials.html#openmm-tutorials" title="Permalink to this headline">¶</a></h1>
<section id="example-files-overview">
<h2><span class="section-number">9.1. </span>Example Files Overview<a class="headerlink" href="03_tutorials.html#example-files-overview" title="Permalink to this headline">¶</a></h2>
<p>Four example files are provided in the examples folder, each designed with
a specific objective.</p>
<ul class="simple">
<li><p><strong>HelloArgon:</strong>  A very simple example intended for verifying that you
have installed OpenMM correctly.  It also introduces you to the basic classes
within OpenMM.</p></li>
<li><p><strong>HelloSodiumChloride:</strong>  This example shows you our recommended strategy
for integrating OpenMM into an existing molecular dynamics code.</p></li>
<li><p><strong>HelloEthane:</strong> The main purpose of this example is to demonstrate how
to tell OpenMM about bonded forces (bond stretch, bond angle bend, dihedral
torsion).</p></li>
<li><p><strong>HelloWaterBox:</strong>  This example shows you how to use OpenMM to model
explicit solvation, including setting up periodic boundary conditions.  It runs
extremely fast on a GPU but very, very slowly on a CPU, so it is an excellent
example to use to compare performance on the GPU versus the CPU.  The other
examples provided use systems where the performance difference would be too
small to notice.</p></li>
</ul>
<p>The two fundamental examples—HelloArgon and HelloSodiumChloride—are provided in
C++, C, and Fortran, as indicated in the table below.  The other two
examples—HelloEthane and HelloWaterBox—follow the same structure as
HelloSodiumChloride but demonstrate more calls within the OpenMM API.  They are
only provided in C++ but can be adapted to run in C and Fortran by following the
mappings described in Chapter <a class="reference internal" href="05_languages_not_cpp.html#using-openmm-with-software-written-in-languages-other-than-c"><span class="std std-numref">11</span></a>.
HelloArgon and HelloSodiumChloride also serve as examples of how to do these mappings.  The
sections below describe the HelloArgon, HelloSodiumChloride, and HelloEthane programs in more detail.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 14%" />
<col style="width: 10%" />
<col style="width: 8%" />
<col style="width: 39%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Example</p></th>
<th class="head"><p>Solvent</p></th>
<th class="head"><p>Thermostat</p></th>
<th class="head"><p>Boundary</p></th>
<th class="head"><p>Forces &amp; Constraints</p></th>
<th class="head"><p>API</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Argon</p></td>
<td><p>Vacuum</p></td>
<td><p>None</p></td>
<td><p>None</p></td>
<td><p>Non-bonded*</p></td>
<td><p>C++, C, Fortran</p></td>
</tr>
<tr class="row-odd"><td><p>Sodium Chloride</p></td>
<td><p>Implicit water</p></td>
<td><p>Langevin</p></td>
<td><p>None</p></td>
<td><p>Non-bonded*</p></td>
<td><p>C++, C, Fortran</p></td>
</tr>
<tr class="row-even"><td><p>Ethane</p></td>
<td><p>Vacuum</p></td>
<td><p>None</p></td>
<td><p>None</p></td>
<td><p>Non-bonded*, stretch, bend, torsion</p></td>
<td><p>C++</p></td>
</tr>
<tr class="row-odd"><td><p>Water Box</p></td>
<td><p>Explicit water</p></td>
<td><p>Andersen</p></td>
<td><p>Periodic</p></td>
<td><p>Non-bonded*, stretch, bend, constraints</p></td>
<td><p>C++</p></td>
</tr>
</tbody>
</table>
<p>*van der Waals and Coulomb forces</p>
</section>
<section id="running-example-files">
<span id="id2"></span><h2><span class="section-number">9.2. </span>Running Example Files<a class="headerlink" href="03_tutorials.html#running-example-files" title="Permalink to this headline">¶</a></h2>
<p>The instructions below are for running the HelloArgon program.  A similar
process would be used to run the other examples.</p>
<section id="visual-studio">
<h3><span class="section-number">9.2.1. </span>Visual Studio<a class="headerlink" href="03_tutorials.html#visual-studio" title="Permalink to this headline">¶</a></h3>
<p>Navigate to wherever you saved the example files.  Descend into the directory
folder VisualStudio. Double-click the file HelloArgon.sln (a Microsoft Visual
Studio Solution file).  Visual Studio will launch.</p>
<p>Note: These files were created using Visual Studio 8.  If you are using a more
recent version, it will ask if you want to convert the files to the new version.
Agree and continue through the conversion process.</p>
<p>In Visual Studio, make sure the “Solution Configuration” is set to “Release” and
not “Debug”.  The “Solution Configuration” can be set using the drop-down menu
in the top toolbar, next to the green arrow (see Figure 9-1
below).  Due to incompatibilities among Visual Studio versions, we do not provide pre-compiled
debug binaries.</p>
<figure class="align-center" id="id6">
<a class="reference internal image-reference" href="../_images/VisualStudioSetConfiguration.jpg"><img alt="../_images/VisualStudioSetConfiguration.jpg" src="../_images/VisualStudioSetConfiguration.jpg" style="width: 100%;" /></a>
<figcaption>
<p><span class="caption-text">Figure 9-1:  Setting “Solution Configuration” to “Release” mode in Visual Studio</span><a class="headerlink" href="03_tutorials.html#id6" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>From the command options select Debug -&gt; Start Without Debugging (or CTRL-F5).
See Figure 9-2.  This will also compile the program, if it has not
previously been compiled.</p>
<figure class="align-center" id="id7">
<a class="reference internal image-reference" href="../_images/VisualStudioLaunch.jpg"><img alt="../_images/VisualStudioLaunch.jpg" src="../_images/VisualStudioLaunch.jpg" style="width: 100%;" /></a>
<figcaption>
<p><span class="caption-text">Figure 9-2:  Run a program in Visual Studio</span><a class="headerlink" href="03_tutorials.html#id7" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>You should see a series of lines like the following output on your screen:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>REMARK  Using OpenMM platform Reference
MODEL     1
ATOM      1  AR   AR     1       0.000   0.000   0.000  1.00  0.00
ATOM      2  AR   AR     1       5.000   0.000   0.000  1.00  0.00
ATOM      3  AR   AR     1       10.000  0.000   0.000  1.00  0.00
ENDMDL

…

MODEL     250
ATOM      1  AR   AR     1       0.233   0.000   0.000  1.00  0.00
ATOM      2  AR   AR     1       5.068   0.000   0.000  1.00  0.00
ATOM      3  AR   AR     1       9.678   0.000   0.000  1.00  0.00
ENDMDL
MODEL     251
ATOM      1  AR   AR     1       0.198   0.000   0.000  1.00  0.00
ATOM      2  AR   AR     1       5.082   0.000   0.000  1.00  0.00
ATOM      3  AR   AR     1       9.698   0.000   0.000  1.00  0.00
ENDMDL
MODEL     252
ATOM      1  AR   AR     1       0.165   0.000   0.000  1.00  0.00
ATOM      2  AR   AR     1       5.097   0.000   0.000  1.00  0.00
ATOM      3  AR   AR     1       9.717   0.000   0.000  1.00  0.00
ENDMDL
</pre></div>
</div>
<section id="determining-the-platform-being-used">
<h4>Determining the platform being used<a class="headerlink" href="03_tutorials.html#determining-the-platform-being-used" title="Permalink to this headline">¶</a></h4>
<p>The very first line of the output will indicate whether you are running on the
CPU (Reference platform) or a GPU (CUDA or OpenCL platform).  It will say one of
the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">REMARK</span>  <span class="n">Using</span> <span class="n">OpenMM</span> <span class="n">platform</span> <span class="n">Reference</span>
<span class="n">REMARK</span>  <span class="n">Using</span> <span class="n">OpenMM</span> <span class="n">platform</span> <span class="n">Cuda</span>
<span class="n">REMARK</span>  <span class="n">Using</span> <span class="n">OpenMM</span> <span class="n">platform</span> <span class="n">OpenCL</span>
</pre></div>
</div>
<p>If you have a supported GPU, the program should, by default, run on the GPU.</p>
</section>
<section id="visualizing-the-results">
<h4>Visualizing the results<a class="headerlink" href="03_tutorials.html#visualizing-the-results" title="Permalink to this headline">¶</a></h4>
<p>You can output the results to a PDB file that could be visualized using programs
like VMD (<a class="reference external" href="http://www.ks.uiuc.edu/Research/vmd/">http://www.ks.uiuc.edu/Research/vmd/</a>) or PyMol
(<a class="reference external" href="http://pymol.sourceforge.net/">http://pymol.sourceforge.net/</a>).  To do this within Visual Studios:</p>
<ol class="arabic">
<li><p>Right-click on the project name HelloArgon (not one of the files) and select
the “Properties” option.</p></li>
<li><p>On the “Property Pages” form, select “Debugging” under the “Configuration
Properties” node.</p></li>
<li><p>In the “Command Arguments” field, type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">argon</span><span class="o">.</span><span class="n">pdb</span>
</pre></div>
</div>
<p>This will save the output to a file called argon.pdb in the current working
directory (default is the VisualStudio directory).  If you want to save it to
another directory, you will need to specify the full path.</p>
</li>
<li><p>Select “OK”</p></li>
</ol>
<p>Now, when you run the program in Visual Studio, no text will appear.  After a
short time, you should see the message “<code class="code docutils literal notranslate"><span class="pre">Press</span> <span class="pre">any</span> <span class="pre">key</span> <span class="pre">to</span> <span class="pre">continue…</span></code>,”
indicating that the program is complete and that the PDB file has been
completely written.</p>
</section>
</section>
<section id="mac-os-x-linux">
<h3><span class="section-number">9.2.2. </span>Mac OS X/Linux<a class="headerlink" href="03_tutorials.html#mac-os-x-linux" title="Permalink to this headline">¶</a></h3>
<p>Navigate to wherever you saved the example files.</p>
<p>Verify your makefile by consulting the MakefileNotes file in this directory, if
necessary.</p>
<p>Type::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span>
</pre></div>
</div>
<p>Then run the program by typing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">HelloArgon</span>
</pre></div>
</div>
<p>You should see a series of lines like the following output on your screen:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">REMARK</span>  <span class="n">Using</span> <span class="n">OpenMM</span> <span class="n">platform</span> <span class="n">Reference</span>
<span class="n">MODEL</span>     <span class="mi">1</span>
<span class="n">ATOM</span>      <span class="mi">1</span>  <span class="n">AR</span>   <span class="n">AR</span>     <span class="mi">1</span>       <span class="mf">0.000</span>   <span class="mf">0.000</span>   <span class="mf">0.000</span>  <span class="mf">1.00</span>  <span class="mf">0.00</span>
<span class="n">ATOM</span>      <span class="mi">2</span>  <span class="n">AR</span>   <span class="n">AR</span>     <span class="mi">1</span>       <span class="mf">5.000</span>   <span class="mf">0.000</span>   <span class="mf">0.000</span>  <span class="mf">1.00</span>  <span class="mf">0.00</span>
<span class="n">ATOM</span>      <span class="mi">3</span>  <span class="n">AR</span>   <span class="n">AR</span>     <span class="mi">1</span>       <span class="mf">10.000</span>  <span class="mf">0.000</span>   <span class="mf">0.000</span>  <span class="mf">1.00</span>  <span class="mf">0.00</span>
<span class="n">ENDMDL</span>

<span class="o">...</span>

<span class="n">MODEL</span>     <span class="mi">250</span>
<span class="n">ATOM</span>      <span class="mi">1</span>  <span class="n">AR</span>   <span class="n">AR</span>     <span class="mi">1</span>       <span class="mf">0.233</span>   <span class="mf">0.000</span>   <span class="mf">0.000</span>  <span class="mf">1.00</span>  <span class="mf">0.00</span>
<span class="n">ATOM</span>      <span class="mi">2</span>  <span class="n">AR</span>   <span class="n">AR</span>     <span class="mi">1</span>       <span class="mf">5.068</span>   <span class="mf">0.000</span>   <span class="mf">0.000</span>  <span class="mf">1.00</span>  <span class="mf">0.00</span>
<span class="n">ATOM</span>      <span class="mi">3</span>  <span class="n">AR</span>   <span class="n">AR</span>     <span class="mi">1</span>       <span class="mf">9.678</span>   <span class="mf">0.000</span>   <span class="mf">0.000</span>  <span class="mf">1.00</span>  <span class="mf">0.00</span>
<span class="n">ENDMDL</span>
<span class="n">MODEL</span>     <span class="mi">251</span>
<span class="n">ATOM</span>      <span class="mi">1</span>  <span class="n">AR</span>   <span class="n">AR</span>     <span class="mi">1</span>       <span class="mf">0.198</span>   <span class="mf">0.000</span>   <span class="mf">0.000</span>  <span class="mf">1.00</span>  <span class="mf">0.00</span>
<span class="n">ATOM</span>      <span class="mi">2</span>  <span class="n">AR</span>   <span class="n">AR</span>     <span class="mi">1</span>       <span class="mf">5.082</span>   <span class="mf">0.000</span>   <span class="mf">0.000</span>  <span class="mf">1.00</span>  <span class="mf">0.00</span>
<span class="n">ATOM</span>      <span class="mi">3</span>  <span class="n">AR</span>   <span class="n">AR</span>     <span class="mi">1</span>       <span class="mf">9.698</span>   <span class="mf">0.000</span>   <span class="mf">0.000</span>  <span class="mf">1.00</span>  <span class="mf">0.00</span>
<span class="n">ENDMDL</span>
<span class="n">MODEL</span>     <span class="mi">252</span>
<span class="n">ATOM</span>      <span class="mi">1</span>  <span class="n">AR</span>   <span class="n">AR</span>     <span class="mi">1</span>       <span class="mf">0.165</span>   <span class="mf">0.000</span>   <span class="mf">0.000</span>  <span class="mf">1.00</span>  <span class="mf">0.00</span>
<span class="n">ATOM</span>      <span class="mi">2</span>  <span class="n">AR</span>   <span class="n">AR</span>     <span class="mi">1</span>       <span class="mf">5.097</span>   <span class="mf">0.000</span>   <span class="mf">0.000</span>  <span class="mf">1.00</span>  <span class="mf">0.00</span>
<span class="n">ATOM</span>      <span class="mi">3</span>  <span class="n">AR</span>   <span class="n">AR</span>     <span class="mi">1</span>       <span class="mf">9.717</span>   <span class="mf">0.000</span>   <span class="mf">0.000</span>  <span class="mf">1.00</span>  <span class="mf">0.00</span>
<span class="n">ENDMDL</span>
</pre></div>
</div>
<section id="id3">
<h4>Determining the platform being used<a class="headerlink" href="03_tutorials.html#id3" title="Permalink to this headline">¶</a></h4>
<p>The very first line of the output will indicate whether you are running on the
CPU (Reference platform) or a GPU (CUDA or OpenCL platform).  It will say one of
the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">REMARK</span>  <span class="n">Using</span> <span class="n">OpenMM</span> <span class="n">platform</span> <span class="n">Reference</span>
<span class="n">REMARK</span>  <span class="n">Using</span> <span class="n">OpenMM</span> <span class="n">platform</span> <span class="n">Cuda</span>
<span class="n">REMARK</span>  <span class="n">Using</span> <span class="n">OpenMM</span> <span class="n">platform</span> <span class="n">OpenCL</span>
</pre></div>
</div>
<p>If you have a supported GPU, the program should, by default, run on the GPU.</p>
</section>
<section id="id4">
<h4>Visualizing the results<a class="headerlink" href="03_tutorials.html#id4" title="Permalink to this headline">¶</a></h4>
<p>You can output the results to a PDB file that could be visualized using programs
like VMD (<a class="reference external" href="http://www.ks.uiuc.edu/Research/vmd/">http://www.ks.uiuc.edu/Research/vmd/</a>) or PyMol
(<a class="reference external" href="http://pymol.sourceforge.net/">http://pymol.sourceforge.net/</a>) by typing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">HelloArgon</span> <span class="o">&gt;</span> <span class="n">argon</span><span class="o">.</span><span class="n">pdb</span>
</pre></div>
</div>
</section>
<section id="compiling-fortran-and-c-examples">
<h4>Compiling Fortran and C examples<a class="headerlink" href="03_tutorials.html#compiling-fortran-and-c-examples" title="Permalink to this headline">¶</a></h4>
<p>The Makefile provided with the examples can also be used to compile the Fortran
and C examples.</p>
<p>The Fortran compiler needs to load a version of the libstdc++.dylib library that
is compatible with the version of gcc used to build OpenMM;   OpenMM for Mac is
compiled using gcc 4.2.  If you are compiling with a different version, edit the
Makefile and add the following flag to FCPPLIBS: <code class="code docutils literal notranslate"><span class="pre">–L/usr/lib/gcc/i686</span>
<span class="pre">-apple-darwin10/4.2.1</span></code>.</p>
<p>When the Makefile has been updated, type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="nb">all</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="helloargon-program">
<h2><span class="section-number">9.3. </span>HelloArgon Program<a class="headerlink" href="03_tutorials.html#helloargon-program" title="Permalink to this headline">¶</a></h2>
<p>The HelloArgon program simulates three argon atoms in a vacuum.  It is a simple
program primarily intended for you to verify that you are able to compile, link,
and run with OpenMM.  It also demonstrates the basic calls needed to run a
simulation using OpenMM.</p>
<section id="including-openmm-defined-functions">
<h3><span class="section-number">9.3.1. </span>Including OpenMM-defined functions<a class="headerlink" href="03_tutorials.html#including-openmm-defined-functions" title="Permalink to this headline">¶</a></h3>
<p>The OpenMM header file <em>OpenMM.h</em> instructs the program to include
everything defined by the OpenMM libraries.  Include the header file by adding
the following line at the top of your program:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &quot;OpenMM.h&quot;</span>
</pre></div>
</div>
</section>
<section id="running-a-program-on-gpu-platforms">
<h3><span class="section-number">9.3.2. </span>Running a program on GPU platforms<a class="headerlink" href="03_tutorials.html#running-a-program-on-gpu-platforms" title="Permalink to this headline">¶</a></h3>
<p>By default, a program will run on the Reference platform.  In order to run a
program on another platform (e.g., an NVIDIA or AMD GPU), you need to load the
required shared libraries for that other platform (e.g., Cuda, OpenCL).  The
easy way to do this is to call:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">OpenMM</span><span class="o">::</span><span class="n">Platform</span><span class="o">::</span><span class="n">loadPluginsFromDirectory</span><span class="p">(</span><span class="n">OpenMM</span><span class="o">::</span><span class="n">Platform</span><span class="o">::</span><span class="n">getDefaultPluginsDirectory</span><span class="p">());</span><span class="w"></span>
</pre></div>
</div>
<p>This will load all the shared libraries (plug-ins) that can be found, so you do
not need to explicitly know which libraries are available on a given machine.
In this way, the program will be able to run on another platform, if it is
available.</p>
</section>
<section id="running-a-simulation-using-the-openmm-public-api">
<h3><span class="section-number">9.3.3. </span>Running a simulation using the OpenMM public API<a class="headerlink" href="03_tutorials.html#running-a-simulation-using-the-openmm-public-api" title="Permalink to this headline">¶</a></h3>
<p>The OpenMM public API was described in Section <a class="reference internal" href="01_introduction.html#the-openmm-public-api"><span class="std std-numref">7.5</span></a>.  Here you will
see how to use those classes to create a simple system of three argon atoms and run a short
simulation.  The main components of the simulation are within the function
<code class="code docutils literal notranslate"><span class="pre">simulateArgon()</span></code>:</p>
<ol class="arabic">
<li><p><strong>System</strong> – We first establish a system and add a non-bonded force to
it.  At this point, there are no particles in the system.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create a system with nonbonded forces.</span>
<span class="n">OpenMM</span><span class="o">::</span><span class="n">System</span><span class="w"> </span><span class="n">system</span><span class="p">;</span><span class="w"></span>
<span class="n">OpenMM</span><span class="o">::</span><span class="n">NonbondedForce</span><span class="o">*</span><span class="w"> </span><span class="n">nonbond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">NonbondedForce</span><span class="p">();</span><span class="w"></span>
<span class="n">system</span><span class="p">.</span><span class="n">addForce</span><span class="p">(</span><span class="n">nonbond</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>We then add the three argon atoms to the system.  For this system, all the data
for the particles are hard-coded into the program.  While not a realistic
scenario, it makes the example simpler and clearer.  The
<code class="code docutils literal notranslate"><span class="pre">std::vector&lt;OpenMM::Vec3&gt;</span></code> is an array of vectors of 3.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create three atoms.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">OpenMM</span><span class="o">::</span><span class="n">Vec3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">initPosInNm</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">initPosInNm</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">Vec3</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// location, nm</span>

<span class="w">    </span><span class="n">system</span><span class="p">.</span><span class="n">addParticle</span><span class="p">(</span><span class="mf">39.95</span><span class="p">);</span><span class="w"> </span><span class="c1">// mass of Ar, grams per mole</span>

<span class="w">    </span><span class="c1">// charge, L-J sigma (nm), well depth (kJ)</span>
<span class="w">    </span><span class="n">nonbond</span><span class="o">-&gt;</span><span class="n">addParticle</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3350</span><span class="p">,</span><span class="w"> </span><span class="mf">0.996</span><span class="p">);</span><span class="w"> </span><span class="c1">// vdWRad(Ar)=.188 nm</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Units:</strong> Be very careful with the units in your program.  It is very easy
to make mistakes with the units, so we recommend including them in your variable
names, as we have done here <code class="code docutils literal notranslate"><span class="pre">initPosInNm</span></code> (position in nanometers).
OpenMM provides conversion constants that should be used whenever there are
conversions to be done; for simplicity, we did not do that in HelloArgon, but
all the other examples show the use of these constants.</p>
<p>It is hard to overemphasize the importance of careful units handling—it is very
easy to make a mistake despite, or perhaps because of, the trivial nature of
units conversion.  For more information about the units used in OpenMM, see
Section <a class="reference internal" href="../theory/01_introduction.html#units"><span class="std std-numref">17.2</span></a>.</p>
<p><strong>Adding Particle Information:</strong> Both the system and the non-bonded
force require information about the particles.  The system just needs to know
the mass of the particle.  The non-bonded force requires information about the
charge (in this case, argon is uncharged), and the Lennard-Jones parameters
sigma (zero-energy separation distance) and well depth (see Section <a class="reference internal" href="../theory/02_standard_forces.html#lennard-jones-interaction"><span class="std std-numref">18.6.1</span></a>
for more details).</p>
<p>Note that the van der Waals radius for argon is 0.188 nm and that it has already
been converted to sigma (0.335 nm) in the example above where it is added to the
non-bonded force;  in your code, you should make use of the appropriate
conversion factor supplied with OpenMM as discussed in Section <a class="reference internal" href="../theory/01_introduction.html#units"><span class="std std-numref">17.2</span></a>.</p>
</li>
<li><p><strong>Integrator</strong> – We next specify the integrator to use to perform the
calculations.  In this case, we choose a Verlet integrator to run a constant
energy simulation.  The only argument required is the step size in picoseconds.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">OpenMM</span><span class="o">::</span><span class="n">VerletIntegrator</span><span class="w"> </span><span class="nf">integrator</span><span class="p">(</span><span class="mf">0.004</span><span class="p">);</span><span class="w"> </span><span class="c1">// step size in ps</span>
</pre></div>
</div>
<p>We have chosen to use 0.004 picoseconds, or 4 femtoseconds, which is larger than
that used in a typical molecular dynamics simulation.  However, since this
example does not have any bonds with higher frequency components, like most
molecular dynamics simulations do, this is an acceptable value.</p>
</li>
<li><p><strong>Context</strong> – The context is an object that consists of an integrator and
a system.  It manages the state of the simulation.  The code below initializes
the context.  We then let the context select the best platform available to run
on, since this is not specifically specified, and print out the chosen platform.
This is useful information, especially when debugging.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Let OpenMM Context choose best platform.</span>
<span class="n">OpenMM</span><span class="o">::</span><span class="n">Context</span><span class="w"> </span><span class="nf">context</span><span class="p">(</span><span class="n">system</span><span class="p">,</span><span class="w"> </span><span class="n">integrator</span><span class="p">);</span><span class="w"></span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;REMARK  Using OpenMM platform %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="n">getPlatform</span><span class="p">().</span><span class="n">getName</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span><span class="w"></span>
</pre></div>
</div>
<p>We then initialize the system, setting the initial time, as well as the initial
positions and velocities of the atoms.  In this example, we leave time and
velocity at their default values of zero.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Set starting positions of the atoms. Leave time and velocity zero.</span>
<span class="n">context</span><span class="p">.</span><span class="n">setPositions</span><span class="p">(</span><span class="n">initPosInNm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p><strong>Initialize and run the simulation</strong> – The next block of code runs the
simulation and saves its output.  For each frame of the simulation (in this
example, a frame is defined by the advancement interval of the integrator; see
below), the current state of the simulation is obtained and written out to a
PDB-formatted file.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Simulate.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">frameNum</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">;</span><span class="o">++</span><span class="n">frameNum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Output current state information.</span>
<span class="w">    </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">State</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="n">getState</span><span class="p">(</span><span class="n">OpenMM</span><span class="o">::</span><span class="n">State</span><span class="o">::</span><span class="n">Positions</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w">  </span><span class="n">timeInPs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">getTime</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">writePdbFrame</span><span class="p">(</span><span class="n">frameNum</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span><span class="w"> </span><span class="c1">// output coordinates</span>
</pre></div>
</div>
<p><em>Getting state information has to be done in bulk, asking for information for
all the particles at once.</em>  This is computationally expensive since this
information can reside on the GPUs and requires communication overhead to
retrieve, so you do not want to do it very often.  In the above code, we only
request the positions, since that is all that is needed, and time from the
state.</p>
<p>The simulation stops after 10 ps; otherwise we ask the integrator to take 10
steps (so one frame is equivalent to 10 time steps).   Normally, we would want
to take more than 10 steps at a time, but to get a reasonable-looking animation,
we use 10.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">timeInPs</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">10.</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Advance state many steps at a time, for efficient use of OpenMM.</span>
<span class="n">integrator</span><span class="p">.</span><span class="n">step</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// (use a lot more than this normally)</span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="error-handling-for-openmm">
<h3><span class="section-number">9.3.4. </span>Error handling for OpenMM<a class="headerlink" href="03_tutorials.html#error-handling-for-openmm" title="Permalink to this headline">¶</a></h3>
<p>Error handling for OpenMM is explicitly designed so you do not have to check the
status after every call.  If anything goes wrong, OpenMM throws an exception.
It uses standard exceptions, so on many platforms, you will get the exception
message automatically.  However, we recommend using <code class="code docutils literal notranslate"><span class="pre">try-catch</span></code> blocks
to ensure you do catch the exception.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">simulateArgon</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// success!</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Catch and report usage and runtime errors detected by OpenMM and fail.</span>
<span class="w">    </span><span class="n">catch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;EXCEPTION: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// failure!</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="writing-out-pdb-files">
<h3><span class="section-number">9.3.5. </span>Writing out PDB files<a class="headerlink" href="03_tutorials.html#writing-out-pdb-files" title="Permalink to this headline">¶</a></h3>
<p>For the HelloArgon program, we provide a simple PDB file writing function
<code class="code docutils literal notranslate"><span class="pre">writePdbFrame</span></code> that <em>only</em> writes out argon atoms.  The function
has nothing to do with OpenMM except for using the OpenMM State.  The function
extracts the positions from the State in nanometers (10<sup>-9</sup> m) and
converts them to Angstroms (10<sup>-10</sup> m) to be compatible with the PDB
format.   Again, we emphasize how important it is to track the units being used!</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">writePdbFrame</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">frameNum</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">State</span><span class="o">&amp;</span><span class="w"> </span><span class="n">state</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Reference atomic positions in the OpenMM State.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">OpenMM</span><span class="o">::</span><span class="n">Vec3</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">posInNm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">getPositions</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Use PDB MODEL cards to number trajectory frames</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;MODEL     %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">frameNum</span><span class="p">);</span><span class="w"> </span><span class="c1">// start of frame</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">posInNm</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;ATOM  %5d  AR   AR     1    &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// atom number</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%8.3f%8.3f%8.3f  1.00  0.00</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w">      </span><span class="c1">// coordinates</span>
<span class="w">        </span><span class="c1">// &quot;*10&quot; converts nanometers to Angstroms</span>
<span class="w">        </span><span class="n">posInNm</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">posInNm</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">posInNm</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;ENDMDL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// end of frame</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">MODEL</span></code> and <code class="code docutils literal notranslate"><span class="pre">ENDMDL</span></code> are used to mark the beginning and end
of a frame, respectively.  By including multiple frames in a PDB file, you can
visualize the simulation trajectory.</p>
</section>
<section id="helloargon-output">
<h3><span class="section-number">9.3.6. </span>HelloArgon output<a class="headerlink" href="03_tutorials.html#helloargon-output" title="Permalink to this headline">¶</a></h3>
<p>The output of the HelloArgon program can be saved to a <em>.pdb</em> file and
visualized using programs like VMD or PyMol (see Section <a class="reference internal" href="03_tutorials.html#running-example-files"><span class="std std-numref">9.2</span></a>).
You should see three atoms moving linearly away and towards one another:</p>
<figure class="align-center">
<img alt="../_images/Argon.png" src="../_images/Argon.png" />
</figure>
<p>You may need to adjust the van der Waals radius in your visualization program to
see the atoms colliding.</p>
</section>
</section>
<section id="hellosodiumchloride-program">
<h2><span class="section-number">9.4. </span>HelloSodiumChloride Program<a class="headerlink" href="03_tutorials.html#hellosodiumchloride-program" title="Permalink to this headline">¶</a></h2>
<p>The HelloSodiumChloride models several sodium (Na<sup>+</sup>) and chloride
(Cl<sup>-</sup>) ions in implicit solvent (using a Generalized Born/Surface Area, or
GBSA, OBC model).  As with the HelloArgon program, only non-bonded forces are
simulated.</p>
<p>The main purpose of this example is to illustrate our recommended strategy for
integrating OpenMM into an existing molecular dynamics (MD) code:</p>
<ol class="arabic simple">
<li><p><strong>Write a few, high-level interface routines containing all your OpenMM
calls</strong>:  Rather than make OpenMM calls throughout your program, we
recommend writing a handful of interface routines that understand both your MD
code’s data structures and OpenMM.  Organize these routines into a separate
compilation unit so you do not have to make huge changes to your existing MD
code.  These routines could be written in any language that is callable from the
existing MD code.  We recommend writing them in C++ since that is what OpenMM is
written in, but you can also write them in C or Fortran; see Chapter
<a class="reference internal" href="05_languages_not_cpp.html#using-openmm-with-software-written-in-languages-other-than-c"><span class="std std-numref">11</span></a>.</p></li>
<li><p><strong>Call only these high-level interface routines from your existing MD
code:</strong>  This provides a clean separation between the existing MD code and
OpenMM, so that changes to OpenMM will not directly impact the existing MD code.
One way to implement this is to use opaque handles, a standard trick used (for
example) for opening files in Linux.  An existing MD code can communicate with
OpenMM via the handle, but knows none of the details of the handle.  It only has
to hold on to the handle and give it back to OpenMM.</p></li>
</ol>
<p>In the example described below, you will see how this strategy can be
implemented for a very simple MD code.  Chapter <a class="reference internal" href="06_integration_examples.html#examples-of-openmm-integration"><span class="std std-numref">12</span></a>
describes the strategies used in integrating OpenMM into real MD codes.</p>
<section id="simple-molecular-dynamics-system">
<span id="id5"></span><h3><span class="section-number">9.4.1. </span>Simple molecular dynamics system<a class="headerlink" href="03_tutorials.html#simple-molecular-dynamics-system" title="Permalink to this headline">¶</a></h3>
<p>The initial sections of HelloSodiumChloride.cpp represent a very simple
molecular dynamics system.  The system includes modeling and simulation
parameters and the atom and force field data.  It also provides a data structure
<code class="code docutils literal notranslate"><span class="pre">posInAng[3]</span></code> for storing the current state.  These sections represent
(in highly simplified form) information that would be available from an existing
MD code, and will be used to demonstrate how to integrate OpenMM with an
existing MD program.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// -----------------------------------------------------------------</span>
<span class="c1">//                   MODELING AND SIMULATION PARAMETERS</span>
<span class="c1">// -----------------------------------------------------------------</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">Temperature</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="mi">300</span><span class="p">;</span><span class="w">     </span><span class="c1">// Kelvins</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">FrictionInPerPs</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mf">91.</span><span class="p">;</span><span class="w">     </span><span class="c1">// collisions per picosecond</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">SolventDielectric</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mf">80.</span><span class="p">;</span><span class="w">     </span><span class="c1">// typical for water</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">SoluteDielectric</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mf">2.</span><span class="p">;</span><span class="w">      </span><span class="c1">// typical for protein</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">StepSizeInFs</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">       </span><span class="c1">// integration step size (fs)</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">ReportIntervalInFs</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">;</span><span class="w">      </span><span class="c1">// how often to issue PDB frame (fs)</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">SimulationTimeInPs</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">     </span><span class="c1">// total simulation time (ps)</span>

<span class="c1">// Decide whether to request energy calculations.</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w">   </span><span class="n">WantEnergy</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>


<span class="c1">// -----------------------------------------------------------------</span>
<span class="c1">//                          ATOM AND FORCE FIELD DATA</span>
<span class="c1">// -----------------------------------------------------------------</span>
<span class="c1">// This is not part of OpenMM; just a struct we can use to collect atom</span>
<span class="c1">// parameters for this example. Normally atom parameters would come from the</span>
<span class="c1">// force field&#39;s parameterization file. We&#39;re going to use data in Angstrom and</span>
<span class="c1">// Kilocalorie units and show how to safely convert to OpenMM&#39;s internal unit</span>
<span class="c1">// system which uses nanometers and kilojoules.</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span> <span class="nc">MyAtomInfo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">pdb</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w">      </span><span class="n">mass</span><span class="p">,</span><span class="w"> </span><span class="n">charge</span><span class="p">,</span><span class="w"> </span><span class="n">vdwRadiusInAng</span><span class="p">,</span><span class="w"> </span><span class="n">vdwEnergyInKcal</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">gbsaRadiusInAng</span><span class="p">,</span><span class="w"> </span><span class="n">gbsaScaleFactor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w">      </span><span class="n">initPosInAng</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w">      </span><span class="n">posInAng</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"> </span><span class="c1">// leave room for runtime state info</span>
<span class="p">}</span><span class="w"> </span><span class="n">atoms</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="c1">// pdb   mass  charge  vdwRad vdwEnergy   gbsaRad gbsaScale  initPos</span>
<span class="p">{</span><span class="s">&quot; NA &quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">22.99</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w">    </span><span class="mf">1.8680</span><span class="p">,</span><span class="w"> </span><span class="mf">0.00277</span><span class="p">,</span><span class="w">    </span><span class="mf">1.992</span><span class="p">,</span><span class="w">   </span><span class="mf">0.8</span><span class="p">,</span><span class="w">     </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">},</span><span class="w"></span>
<span class="p">{</span><span class="s">&quot; CL &quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">35.45</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w">    </span><span class="mf">2.4700</span><span class="p">,</span><span class="w"> </span><span class="mf">0.1000</span><span class="p">,</span><span class="w">     </span><span class="mf">1.735</span><span class="p">,</span><span class="w">   </span><span class="mf">0.8</span><span class="p">,</span><span class="w">    </span><span class="mi">-8</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">},</span><span class="w"></span>
<span class="p">{</span><span class="s">&quot; NA &quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">22.99</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w">    </span><span class="mf">1.8680</span><span class="p">,</span><span class="w"> </span><span class="mf">0.00277</span><span class="p">,</span><span class="w">    </span><span class="mf">1.992</span><span class="p">,</span><span class="w">   </span><span class="mf">0.8</span><span class="p">,</span><span class="w">     </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">},</span><span class="w"></span>
<span class="p">{</span><span class="s">&quot; CL &quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">35.45</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w">    </span><span class="mf">2.4700</span><span class="p">,</span><span class="w"> </span><span class="mf">0.1000</span><span class="p">,</span><span class="w">     </span><span class="mf">1.735</span><span class="p">,</span><span class="w">   </span><span class="mf">0.8</span><span class="p">,</span><span class="w">     </span><span class="mi">0</span><span class="p">,</span><span class="mi">-9</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">},</span><span class="w"></span>
<span class="p">{</span><span class="s">&quot; NA &quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">22.99</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w">    </span><span class="mf">1.8680</span><span class="p">,</span><span class="w"> </span><span class="mf">0.00277</span><span class="p">,</span><span class="w">    </span><span class="mf">1.992</span><span class="p">,</span><span class="w">   </span><span class="mf">0.8</span><span class="p">,</span><span class="w">     </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="mi">-10</span><span class="p">},</span><span class="w"></span>
<span class="p">{</span><span class="s">&quot; CL &quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">35.45</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w">    </span><span class="mf">2.4700</span><span class="p">,</span><span class="w"> </span><span class="mf">0.1000</span><span class="p">,</span><span class="w">     </span><span class="mf">1.735</span><span class="p">,</span><span class="w">   </span><span class="mf">0.8</span><span class="p">,</span><span class="w">     </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">},</span><span class="w"></span>
<span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">}</span><span class="w"> </span><span class="c1">// end of list</span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="interface-routines">
<h3><span class="section-number">9.4.2. </span>Interface routines<a class="headerlink" href="03_tutorials.html#interface-routines" title="Permalink to this headline">¶</a></h3>
<p>The key to our recommended integration strategy is the interface routines.  You
will need to decide what interface routines are required for effective
communication between your existing MD program and OpenMM, but typically there
will only be six or seven.  In our example, the following four routines suffice:</p>
<ul class="simple">
<li><p><strong>Initialize:</strong> Data structures that already exist in your MD program
(i.e., force fields, constraints, atoms in the system) are passed to the
<code class="code docutils literal notranslate"><span class="pre">Initialize</span></code> routine, which makes appropriate calls to OpenMM and then
returns a handle to the OpenMM object that can be used by the existing MD
program.</p></li>
<li><p><strong>Terminate:</strong> Clean up the heap space allocated by <code class="code docutils literal notranslate"><span class="pre">Initialize</span></code>
by passing the handle to the <code class="code docutils literal notranslate"><span class="pre">Terminate</span></code> routine.</p></li>
<li><p><strong>Advance State:</strong> The <code class="code docutils literal notranslate"><span class="pre">AdvanceState</span></code> routine advances the
simulation.  It requires that the calling function, the existing MD code, gives
it a handle.</p></li>
<li><p><strong>Retrieve State:</strong> When you want to do an analysis or generate some kind
of report, you call the <code class="code docutils literal notranslate"><span class="pre">RetrieveState</span></code> routine.  You have to give it
a handle.  It then fills in a data structure that is defined in the existing MD
code, allowing the MD program to use it in its existing routines without further
modification.</p></li>
</ul>
<p>Note that these are just descriptions of the routines’ functions—you can call
them anything you like and implement them in whatever way makes sense for your
MD code.</p>
<p>In the example code, the four routines performing these functions, plus an
opaque data structure (the handle), would be declared, as shown below.  Then,
the main program, which sets up, runs, and reports on the simulation, accesses
these routines and the opaque data structure (in this case, the variable
<code class="code docutils literal notranslate"><span class="pre">omm</span></code>).  As you can see, it does not have access to any OpenMM
declarations, only to the interface routines that you write so there is no need
to change the build environment.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">MyOpenMMData</span><span class="p">;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="n">MyOpenMMData</span><span class="o">*</span><span class="w"> </span><span class="nf">myInitializeOpenMM</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyAtomInfo</span><span class="w"> </span><span class="n">atoms</span><span class="p">[],</span><span class="w"></span>
<span class="w">                                        </span><span class="kt">double</span><span class="w"> </span><span class="n">temperature</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="kt">double</span><span class="w"> </span><span class="n">frictionInPs</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="kt">double</span><span class="w"> </span><span class="n">solventDielectric</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="kt">double</span><span class="w"> </span><span class="n">soluteDielectric</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="kt">double</span><span class="w"> </span><span class="n">stepSizeInFs</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">platformName</span><span class="p">);</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w">          </span><span class="nf">myStepWithOpenMM</span><span class="p">(</span><span class="n">MyOpenMMData</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numSteps</span><span class="p">);</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w">          </span><span class="nf">myGetOpenMMState</span><span class="p">(</span><span class="n">MyOpenMMData</span><span class="o">*</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="kt">bool</span><span class="w"> </span><span class="n">wantEnergy</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">energy</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="n">MyAtomInfo</span><span class="w"> </span><span class="n">atoms</span><span class="p">[]);</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w">          </span><span class="nf">myTerminateOpenMM</span><span class="p">(</span><span class="n">MyOpenMMData</span><span class="o">*</span><span class="p">);</span><span class="w"></span>


<span class="c1">// -----------------------------------------------------------------</span>
<span class="c1">//                                MAIN PROGRAM</span>
<span class="c1">// -----------------------------------------------------------------</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">NumReports</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">SimulationTimeInPs</span><span class="o">*</span><span class="mi">1000</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">ReportIntervalInFs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.5</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">NumSilentSteps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">ReportIntervalInFs</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">StepSizeInFs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.5</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// ALWAYS enclose all OpenMM calls with a try/catch block to make sure that</span>
<span class="w">    </span><span class="c1">// usage and runtime errors are caught and reported.</span>
<span class="w">    </span><span class="n">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">double</span><span class="w">        </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">energy</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w">   </span><span class="n">platformName</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Set up OpenMM data structures; returns OpenMM Platform name.</span>
<span class="w">        </span><span class="n">MyOpenMMData</span><span class="o">*</span><span class="w"> </span><span class="n">omm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myInitializeOpenMM</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span><span class="w"> </span><span class="n">Temperature</span><span class="p">,</span><span class="w"> </span><span class="n">FrictionInPerPs</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">SolventDielectric</span><span class="p">,</span><span class="w"> </span><span class="n">SoluteDielectric</span><span class="p">,</span><span class="w"> </span><span class="n">StepSizeInFs</span><span class="p">,</span><span class="w"> </span><span class="n">platformName</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Run the simulation:</span>
<span class="w">        </span><span class="c1">//  (1) Write the first line of the PDB file and the initial configuration.</span>
<span class="w">        </span><span class="c1">//  (2) Run silently entirely within OpenMM between reporting intervals.</span>
<span class="w">        </span><span class="c1">//  (3) Write a PDB frame when the time comes.</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;REMARK  Using OpenMM platform %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">platformName</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="n">myGetOpenMMState</span><span class="p">(</span><span class="n">omm</span><span class="p">,</span><span class="w"> </span><span class="n">WantEnergy</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">energy</span><span class="p">,</span><span class="w"> </span><span class="n">atoms</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">myWritePDBFrame</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">energy</span><span class="p">,</span><span class="w"> </span><span class="n">atoms</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">frame</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">NumReports</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">frame</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">myStepWithOpenMM</span><span class="p">(</span><span class="n">omm</span><span class="p">,</span><span class="w"> </span><span class="n">NumSilentSteps</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">myGetOpenMMState</span><span class="p">(</span><span class="n">omm</span><span class="p">,</span><span class="w"> </span><span class="n">WantEnergy</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">energy</span><span class="p">,</span><span class="w"> </span><span class="n">atoms</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">myWritePDBFrame</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">energy</span><span class="p">,</span><span class="w"> </span><span class="n">atoms</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Clean up OpenMM data structures.</span>
<span class="w">        </span><span class="n">myTerminateOpenMM</span><span class="p">(</span><span class="n">omm</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Normal return from main.</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Catch and report usage and runtime errors detected by OpenMM and fail.</span>
<span class="w">    </span><span class="n">catch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;EXCEPTION: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>We will examine the implementation of each of the four interface routines and
the opaque data structure (handle) in the sections below.</p>
<section id="units">
<h4>Units<a class="headerlink" href="03_tutorials.html#units" title="Permalink to this headline">¶</a></h4>
<p>The simple molecular dynamics system described in Section <a class="reference internal" href="03_tutorials.html#simple-molecular-dynamics-system"><span class="std std-numref">9.4.1</span></a>
employs the commonly used units of angstroms and kcals.  These differ from the units and
parameters used within OpenMM (see Section <a class="reference internal" href="../theory/01_introduction.html#units"><span class="std std-numref">17.2</span></a>): nanometers and kilojoules.
These differences may be small but they are critical and must be carefully
accounted for in the interface routines.</p>
</section>
<section id="lennard-jones-potential">
<h4>Lennard-Jones potential<a class="headerlink" href="03_tutorials.html#lennard-jones-potential" title="Permalink to this headline">¶</a></h4>
<p>The Lennard-Jones potential describes the energy between two identical atoms as
the distance between them varies.</p>
<p>The van der Waals “size” parameter is used to identify the distance at which the
energy between these two atoms is at a minimum (that is, where the van der Waals
force is most attractive).  There are several ways to specify this parameter,
typically, either as the van der Waals radius r<sub>vdw</sub> or as the actual
distance between the two atoms d<sub>min</sub> (also called r<sub>min</sub>),
which is twice the van der Waals radius r<sub>vdw</sub>.  A third way to
describe the potential is through sigma <span class="math notranslate nohighlight">\(\sigma\)</span>, which identifies the distance at
which the energy function crosses zero as the atoms move closer together than
d<sub>min</sub>.  (See Section <a class="reference internal" href="../theory/02_standard_forces.html#lennard-jones-interaction"><span class="std std-numref">18.6.1</span></a> for more details about the
relationship between these).</p>
<p><span class="math notranslate nohighlight">\(\sigma\)</span> turns out to be about 0.89*d<sub>min</sub>, which is close enough to
d<sub>min</sub> that it makes it hard to distinguish the two.  Be very careful that
you use the correct value.  In the example below, we will show you how to use
the built-in OpenMM conversion constants to avoid errors.</p>
<p>Lennard-Jones parameters are defined for pairs of identical atoms, but must also
be applied to pairs of dissimilar atoms. That is done by “combining rules” that
differ among popular MD codes. Two of the most common are:</p>
<ul class="simple">
<li><p>Lorentz-Berthelot (used by AMBER, CHARMM):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[r=\frac{r_i+r_j}{2}, \epsilon=\sqrt{\epsilon_i \epsilon_j}\]</div>
<ul class="simple">
<li><p>Jorgensen (used by OPLS):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[r=\sqrt{r_i r_j}, \epsilon=\sqrt{\epsilon_i \epsilon_j}\]</div>
<p>where <em>r</em> = the effective van der Waals “size” parameter (minimum radius,
minimum distance, or zero crossing (sigma)), and <span class="math notranslate nohighlight">\(\epsilon\)</span> = the effective van
der Waals energy well depth parameter, for the dissimilar pair of atoms <em>i</em>
and <em>j</em>.</p>
<p>OpenMM only implements Lorentz-Berthelot directly, but others can be implemented
using the CustomNonbondedForce class.  (See Section <a class="reference internal" href="../theory/03_custom_forces.html#customnonbondedforce"><span class="std std-numref">19.4</span></a> for details.)</p>
</section>
<section id="opaque-handle-myopenmmdata">
<h4>Opaque handle MyOpenMMData<a class="headerlink" href="03_tutorials.html#opaque-handle-myopenmmdata" title="Permalink to this headline">¶</a></h4>
<p>In this example, the handle used by the interface to OpenMM is a pointer to a
struct called <code class="code docutils literal notranslate"><span class="pre">MyOpenMMData.</span></code>  The pointer itself is opaque, meaning
the calling program has no knowledge of what the layout of the object it points
to is, or how to use it to directly interface with OpenMM.  The calling program
will simply pass this opaque handle from one interface routine to another.</p>
<p>There are many different ways to implement the handle.  The code below shows
just one example.  A simulation requires three OpenMM objects (a System, a
Context, and an Integrator) and so these must exist within the handle.  If other
objects were required for a simulation, you would just add them to your handle;
there would be no change in the main program using the handle.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">MyOpenMMData</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MyOpenMMData</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">system</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">context</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">integrator</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">    </span><span class="o">~</span><span class="n">MyOpenMMData</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="n">delete</span><span class="w"> </span><span class="n">system</span><span class="p">;</span><span class="w"> </span><span class="n">delete</span><span class="w"> </span><span class="n">context</span><span class="p">;</span><span class="w"> </span><span class="n">delete</span><span class="w"> </span><span class="n">integrator</span><span class="p">;}</span><span class="w"></span>
<span class="w">    </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">System</span><span class="o">*</span><span class="w">         </span><span class="n">system</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">Context</span><span class="o">*</span><span class="w">        </span><span class="n">context</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">Integrator</span><span class="o">*</span><span class="w">     </span><span class="n">integrator</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>In addition to establishing pointers to the required three OpenMM objects,
<code class="code docutils literal notranslate"><span class="pre">MyOpenMMData</span></code> has a constructor <code class="code docutils literal notranslate"><span class="pre">MyOpenMMData()</span></code> that sets
the pointers for the three OpenMM objects to zero and a destructor
<code class="code docutils literal notranslate"><span class="pre">~MyOpenMMData()</span></code> that (in C++) gives the heap space back.  This was
done in-line in the HelloArgon program, but we recommend you use something like
the method here instead.</p>
</section>
<section id="myinitializeopenmm">
<h4>myInitializeOpenMM<a class="headerlink" href="03_tutorials.html#myinitializeopenmm" title="Permalink to this headline">¶</a></h4>
<p>The <code class="code docutils literal notranslate"><span class="pre">myInitializeOpenMM</span></code> function takes the data structures and
simulation parameters from the existing MD code and returns a new handle that
can be used to do efficient computations with OpenMM.  It also returns the
<code class="code docutils literal notranslate"><span class="pre">platformName</span></code> so the calling program knows what platform (e.g., CUDA,
OpenCL, Reference) was used.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">MyOpenMMData</span><span class="o">*</span><span class="w"></span>
<span class="n">myInitializeOpenMM</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">MyAtomInfo</span><span class="w">    </span><span class="n">atoms</span><span class="p">[],</span><span class="w"></span>
<span class="w">                    </span><span class="kt">double</span><span class="w">              </span><span class="n">temperature</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="kt">double</span><span class="w">              </span><span class="n">frictionInPs</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="kt">double</span><span class="w">              </span><span class="n">solventDielectric</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="kt">double</span><span class="w">              </span><span class="n">soluteDielectric</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="kt">double</span><span class="w">              </span><span class="n">stepSizeInFs</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w">        </span><span class="n">platformName</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This initialization routine is very similar to the HelloArgon example program,
except that objects are created and put in the handle.  For instance, just as in
the HelloArgon program, the first step is to load the OpenMM plug-ins, so that
the program will run on the best performing platform that is available.   Then,
a System is created <strong>and</strong> assigned to the handle <code class="code docutils literal notranslate"><span class="pre">omm</span></code>.
Similarly, forces are added to the System which is already in the handle.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Load all available OpenMM plugins from their default location.</span>
<span class="n">OpenMM</span><span class="o">::</span><span class="n">Platform</span><span class="o">::</span><span class="n">loadPluginsFromDirectory</span><span class="w"></span>
<span class="w">       </span><span class="p">(</span><span class="n">OpenMM</span><span class="o">::</span><span class="n">Platform</span><span class="o">::</span><span class="n">getDefaultPluginsDirectory</span><span class="p">());</span><span class="w"></span>

<span class="c1">// Allocate space to hold OpenMM objects while we&#39;re using them.</span>
<span class="n">MyOpenMMData</span><span class="o">*</span><span class="w"> </span><span class="n">omm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">MyOpenMMData</span><span class="p">();</span><span class="w"></span>

<span class="c1">// Create a System and Force objects within the System. Retain a reference</span>
<span class="c1">// to each force object so we can fill in the forces. Note: the OpenMM</span>
<span class="c1">// System takes ownership of the force objects;don&#39;t delete them yourself.</span>
<span class="n">omm</span><span class="o">-&gt;</span><span class="n">system</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">System</span><span class="p">();</span><span class="w"></span>
<span class="n">OpenMM</span><span class="o">::</span><span class="n">NonbondedForce</span><span class="o">*</span><span class="w"> </span><span class="n">nonbond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">NonbondedForce</span><span class="p">();</span><span class="w"></span>
<span class="n">OpenMM</span><span class="o">::</span><span class="n">GBSAOBCForce</span><span class="o">*</span><span class="w">   </span><span class="n">gbsa</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">GBSAOBCForce</span><span class="p">();</span><span class="w"></span>
<span class="n">omm</span><span class="o">-&gt;</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">addForce</span><span class="p">(</span><span class="n">nonbond</span><span class="p">);</span><span class="w"></span>
<span class="n">omm</span><span class="o">-&gt;</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">addForce</span><span class="p">(</span><span class="n">gbsa</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Specify dielectrics for GBSA implicit solvation.</span>
<span class="n">gbsa</span><span class="o">-&gt;</span><span class="n">setSolventDielectric</span><span class="p">(</span><span class="n">solventDielectric</span><span class="p">);</span><span class="w"></span>
<span class="n">gbsa</span><span class="o">-&gt;</span><span class="n">setSoluteDielectric</span><span class="p">(</span><span class="n">soluteDielectric</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>In the next step, atoms are added to the System within the handle, with
information about each atom coming from the data structure that was passed into
the initialization function from the existing MD code.  As shown in the
HelloArgon program, both the System and the forces need information about the
atoms.  For those unfamiliar with the C++ Standard Template Library, the
<code class="code docutils literal notranslate"><span class="pre">push_back</span></code> function called at the end of this code snippet just adds
the given argument to the end of a C++ “vector” container.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Specify the atoms and their properties:</span>
<span class="c1">//  (1) System needs to know the masses.</span>
<span class="c1">//  (2) NonbondedForce needs charges,van der Waals properties(in MD units!).</span>
<span class="c1">//  (3) GBSA needs charge, radius, and scale factor.</span>
<span class="c1">//  (4) Collect default positions for initializing the simulation later.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vec3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">initialPosInNm</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="o">*</span><span class="n">atoms</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">pdb</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="k">const</span><span class="w"> </span><span class="n">MyAtomInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">atom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoms</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"></span>

<span class="w">     </span><span class="n">omm</span><span class="o">-&gt;</span><span class="n">system</span><span class="o">-&gt;</span><span class="n">addParticle</span><span class="p">(</span><span class="n">atom</span><span class="p">.</span><span class="n">mass</span><span class="p">);</span><span class="w"></span>

<span class="w">     </span><span class="n">nonbond</span><span class="o">-&gt;</span><span class="n">addParticle</span><span class="p">(</span><span class="n">atom</span><span class="p">.</span><span class="n">charge</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="n">atom</span><span class="p">.</span><span class="n">vdwRadiusInAng</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">NmPerAngstrom</span><span class="w"></span>
<span class="w">                                             </span><span class="o">*</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">SigmaPerVdwRadius</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="n">atom</span><span class="p">.</span><span class="n">vdwEnergyInKcal</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">KJPerKcal</span><span class="p">);</span><span class="w"></span>

<span class="w">     </span><span class="n">gbsa</span><span class="o">-&gt;</span><span class="n">addParticle</span><span class="p">(</span><span class="n">atom</span><span class="p">.</span><span class="n">charge</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">atom</span><span class="p">.</span><span class="n">gbsaRadiusInAng</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">NmPerAngstrom</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">atom</span><span class="p">.</span><span class="n">gbsaScaleFactor</span><span class="p">);</span><span class="w"></span>

<span class="w">     </span><span class="c1">// Convert the initial position to nm and append to the array.</span>
<span class="w">     </span><span class="k">const</span><span class="w"> </span><span class="n">Vec3</span><span class="w"> </span><span class="nf">posInNm</span><span class="p">(</span><span class="n">atom</span><span class="p">.</span><span class="n">initPosInAng</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">NmPerAngstrom</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">atom</span><span class="p">.</span><span class="n">initPosInAng</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">NmPerAngstrom</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">atom</span><span class="p">.</span><span class="n">initPosInAng</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">NmPerAngstrom</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="n">initialPosInNm</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">posInNm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Units:</strong>  Here we emphasize the need to pay special attention to the
units.   As mentioned earlier, the existing MD code in this example uses units
of angstroms and kcals, but OpenMM uses nanometers and kilojoules.  So the
initialization routine will need to convert the values from the existing MD code
into the OpenMM units before assigning them to the OpenMM objects.</p>
<p>In the code above, we have used the unit conversion constants that come with
OpenMM (e.g., <code class="code docutils literal notranslate"><span class="pre">OpenMM::NmPerAngstrom</span></code>) to perform these conversions.
Combined with the naming convention of including the units in the variable name
(e.g., <code class="code docutils literal notranslate"><span class="pre">initPosInAng</span></code>), the unit conversion constants are useful
reminders to pay attention to units and minimize errors.</p>
<p>Finally, the initialization routine creates the Integrator and Context for the
simulation.  Again, note the change in units for the arguments!   The routine
then gets the platform that will be used to run the simulation and returns that,
along with the handle <code class="code docutils literal notranslate"><span class="pre">omm</span></code>, back to the calling function.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Choose an Integrator for advancing time, and a Context connecting the</span>
<span class="c1">// System with the Integrator for simulation. Let the Context choose the</span>
<span class="c1">// best available Platform. Initialize the configuration from the default</span>
<span class="c1">// positions we collected above. Initial velocities will be zero but could</span>
<span class="c1">// have been set here.</span>
<span class="n">omm</span><span class="o">-&gt;</span><span class="n">integrator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">LangevinMiddleIntegrator</span><span class="p">(</span><span class="n">temperature</span><span class="p">,</span><span class="w"></span>
<span class="n">frictionInPs</span><span class="p">,</span><span class="w"></span>
<span class="n">stepSizeInFs</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">PsPerFs</span><span class="p">);</span><span class="w"></span>
<span class="n">omm</span><span class="o">-&gt;</span><span class="n">context</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">Context</span><span class="p">(</span><span class="o">*</span><span class="n">omm</span><span class="o">-&gt;</span><span class="n">system</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">omm</span><span class="o">-&gt;</span><span class="n">integrator</span><span class="p">);</span><span class="w"></span>
<span class="n">omm</span><span class="o">-&gt;</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">setPositions</span><span class="p">(</span><span class="n">initialPosInNm</span><span class="p">);</span><span class="w"></span>

<span class="n">platformName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omm</span><span class="o">-&gt;</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">getPlatform</span><span class="p">().</span><span class="n">getName</span><span class="p">();</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="n">omm</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="mygetopenmmstate">
<h4>myGetOpenMMState<a class="headerlink" href="03_tutorials.html#mygetopenmmstate" title="Permalink to this headline">¶</a></h4>
<p>The <code class="code docutils literal notranslate"><span class="pre">myGetOpenMMState</span></code> function takes the handle and returns the time,
energy, and data structure for the atoms in a way that the existing MD code can
use them without modification.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="n">myGetOpenMMState</span><span class="p">(</span><span class="n">MyOpenMMData</span><span class="o">*</span><span class="w"> </span><span class="n">omm</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">wantEnergy</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">timeInPs</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">energyInKcal</span><span class="p">,</span><span class="w"> </span><span class="n">MyAtomInfo</span><span class="w"> </span><span class="n">atoms</span><span class="p">[])</span><span class="w"></span>
</pre></div>
</div>
<p>Again, this is another interface routine in which you need to be very careful of
your units!  Note the conversion from the OpenMM units back to the units used in
the existing MD code.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">infoMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">infoMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">State</span><span class="o">::</span><span class="n">Positions</span><span class="p">;</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">wantEnergy</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">infoMask</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">State</span><span class="o">::</span><span class="n">Velocities</span><span class="p">;</span><span class="w"> </span><span class="c1">// for kinetic energy (cheap)</span>
<span class="w">   </span><span class="n">infoMask</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">State</span><span class="o">::</span><span class="n">Energy</span><span class="p">;</span><span class="w">     </span><span class="c1">// for pot. energy (more expensive)</span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Forces are also available (and cheap).</span>

<span class="k">const</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">State</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omm</span><span class="o">-&gt;</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">getState</span><span class="p">(</span><span class="n">infoMask</span><span class="p">);</span><span class="w"></span>
<span class="n">timeInPs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">getTime</span><span class="p">();</span><span class="w"> </span><span class="c1">// OpenMM time is in ps already</span>

<span class="c1">// Copy OpenMM positions into atoms array and change units from nm to Angstroms.</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vec3</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">positionsInNm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">getPositions</span><span class="p">();</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">positionsInNm</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">posInAng</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">positionsInNm</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">AngstromsPerNm</span><span class="p">;</span><span class="w"></span>

<span class="c1">// If energy has been requested, obtain it and convert from kJ to kcal.</span>
<span class="n">energyInKcal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">wantEnergy</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">energyInKcal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">getPotentialEnergy</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">getKineticEnergy</span><span class="p">())</span><span class="w"></span>
<span class="w">                  </span><span class="o">*</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">KcalPerKJ</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="mystepwithopenmm">
<h4>myStepWithOpenMM<a class="headerlink" href="03_tutorials.html#mystepwithopenmm" title="Permalink to this headline">¶</a></h4>
<p>The <code class="code docutils literal notranslate"><span class="pre">myStepWithOpenMM</span></code> routine takes the handle, uses it to find the
Integrator, and then sets the number of steps for the Integrator to take.  It
does not return any values.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="nf">myStepWithOpenMM</span><span class="p">(</span><span class="n">MyOpenMMData</span><span class="o">*</span><span class="w"> </span><span class="n">omm</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numSteps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">omm</span><span class="o">-&gt;</span><span class="n">integrator</span><span class="o">-&gt;</span><span class="n">step</span><span class="p">(</span><span class="n">numSteps</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="myterminateopenmm">
<h4>myTerminateOpenMM<a class="headerlink" href="03_tutorials.html#myterminateopenmm" title="Permalink to this headline">¶</a></h4>
<p>The <code class="code docutils literal notranslate"><span class="pre">myTerminateOpenMM</span></code> routine takes the handle and deletes all the
components, e.g., the Context and System, cleaning up the heap space.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="nf">myTerminateOpenMM</span><span class="p">(</span><span class="n">MyOpenMMData</span><span class="o">*</span><span class="w"> </span><span class="n">omm</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">delete</span><span class="w"> </span><span class="n">omm</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="helloethane-program">
<h2><span class="section-number">9.5. </span>HelloEthane Program<a class="headerlink" href="03_tutorials.html#helloethane-program" title="Permalink to this headline">¶</a></h2>
<p>The HelloEthane program simulates ethane (H3-C-C-H3) in a vacuum.  It is
structured similarly to the HelloSodiumChloride example, but includes bonded
forces (bond stretch, bond angle bend, dihedral torsion).  In setting up these
bonded forces, the program illustrates some of the other inconsistencies in
definitions and units that you should watch out for.</p>
<p>The bonded forces are added to the system within the initialization interface
routine, similar to how the non-bonded forces were added in the
HelloSodiumChloride example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create a System and Force objects within the System. Retain a reference</span>
<span class="c1">// to each force object so we can fill in the forces. Note: the System owns</span>
<span class="c1">// the force objects and will take care of deleting them; don&#39;t do it yourself!</span>
<span class="n">OpenMM</span><span class="o">::</span><span class="n">System</span><span class="o">&amp;</span><span class="w">                 </span><span class="n">system</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">omm</span><span class="o">-&gt;</span><span class="n">system</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">System</span><span class="p">());</span><span class="w"></span>
<span class="n">OpenMM</span><span class="o">::</span><span class="n">NonbondedForce</span><span class="o">&amp;</span><span class="w">         </span><span class="n">nonbond</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">new</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">NonbondedForce</span><span class="p">();</span><span class="w"></span>
<span class="n">OpenMM</span><span class="o">::</span><span class="n">HarmonicBondForce</span><span class="o">&amp;</span><span class="w">      </span><span class="n">bondStretch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">new</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">HarmonicBondForce</span><span class="p">();</span><span class="w"></span>
<span class="n">OpenMM</span><span class="o">::</span><span class="n">HarmonicAngleForce</span><span class="o">&amp;</span><span class="w">     </span><span class="n">bondBend</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">new</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">HarmonicAngleForce</span><span class="p">();</span><span class="w"></span>
<span class="n">OpenMM</span><span class="o">::</span><span class="n">PeriodicTorsionForce</span><span class="o">&amp;</span><span class="w">   </span><span class="n">bondTorsion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">new</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">PeriodicTorsionForce</span><span class="p">();</span><span class="w"></span>
<span class="n">system</span><span class="p">.</span><span class="n">addForce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nonbond</span><span class="p">);</span><span class="w"></span>
<span class="n">system</span><span class="p">.</span><span class="n">addForce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bondStretch</span><span class="p">);</span><span class="w"></span>
<span class="n">system</span><span class="p">.</span><span class="n">addForce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bondBend</span><span class="p">);</span><span class="w"></span>
<span class="n">system</span><span class="p">.</span><span class="n">addForce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bondTorsion</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Constrainable and non-constrainable bonds:</strong>  In the initialization
routine, we also set up the bonds.  If constraints are being used, then we tell
the System about the constrainable bonds:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">bondPairs</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bonds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">EndOfList</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w">      </span><span class="n">atom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bonds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">atoms</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">BondType</span><span class="o">&amp;</span><span class="w"> </span><span class="n">bond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bondType</span><span class="p">[</span><span class="n">bonds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">UseConstraints</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">bond</span><span class="p">.</span><span class="n">canConstrain</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">system</span><span class="p">.</span><span class="n">addConstraint</span><span class="p">(</span><span class="n">atom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">atom</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"></span>
<span class="w">                </span><span class="n">bond</span><span class="p">.</span><span class="n">nominalLengthInAngstroms</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">NmPerAngstrom</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Otherwise, we need to give the HarmonicBondForce the bond stretch parameters.</p>
<p><strong>Warning</strong><em>:</em> The constant used to specify the stiffness may be defined
differently between the existing MD code and OpenMM.  For instance, AMBER uses
the constant, as given in the harmonic <em>energy</em> term kx<sup>2</sup>, where
the force is 2kx (k = constant and x = distance).  OpenMM wants the constant, as
used in the <em>force</em> term kx (with energy 0.5 * kx<sup>2</sup>).  So a factor
of 2 must be introduced when setting the bond stretch parameters in an OpenMM
system using data from an AMBER system.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bondStretch</span><span class="p">.</span><span class="n">addBond</span><span class="p">(</span><span class="n">atom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">atom</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">bond</span><span class="p">.</span><span class="n">nominalLengthInAngstroms</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">NmPerAngstrom</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">bond</span><span class="p">.</span><span class="n">stiffnessInKcalPerAngstrom2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">KJPerKcal</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">                    </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">AngstromsPerNm</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">AngstromsPerNm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Non-bond exclusions:</strong> Next, we deal with non-bond exclusions. These are
used for pairs of atoms that appear close to one another in the network of bonds
in a molecule. For atoms that close, normal non-bonded forces do not apply or
are reduced in magnitude.  First, we create a list of bonds to generate the non-
bond exclusions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bondPairs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">atom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">atom</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span><span class="w"></span>
</pre></div>
</div>
<p>OpenMM’s non-bonded force provides a convenient routine for creating the common
exceptions. These are: (1) for atoms connected by one bond (1-2) or connected by
just one additional bond (1-3), Coulomb and van der Waals terms do not apply;
and (2) for atoms connected by three bonds (1-4), Coulomb and van der Waals
terms apply but are reduced by a force-field dependent scale factor.  In
general, you may introduce additional exceptions, but the standard ones suffice
here and in many other circumstances.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Exclude 1-2, 1-3 bonded atoms from nonbonded forces, and scale down 1-4 bonded atoms.</span>
<span class="n">nonbond</span><span class="p">.</span><span class="n">createExceptionsFromBonds</span><span class="p">(</span><span class="n">bondPairs</span><span class="p">,</span><span class="w"> </span><span class="n">Coulomb14Scale</span><span class="p">,</span><span class="w"> </span><span class="n">LennardJones14Scale</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Create the 1-2-3 bond angle harmonic terms.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">EndOfList</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w">       </span><span class="n">atom</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">atoms</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="k">const</span><span class="w"> </span><span class="n">AngleType</span><span class="o">&amp;</span><span class="w"> </span><span class="n">angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">angleType</span><span class="p">[</span><span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">];</span><span class="w"></span>

<span class="c1">// See note under bond stretch above regarding the factor of 2 here.</span>
<span class="n">bondBend</span><span class="p">.</span><span class="n">addAngle</span><span class="p">(</span><span class="n">atom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">atom</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">atom</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"></span>
<span class="n">angle</span><span class="p">.</span><span class="n">nominalAngleInDegrees</span><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">RadiansPerDegree</span><span class="p">,</span><span class="w"></span>
<span class="n">angle</span><span class="p">.</span><span class="n">stiffnessInKcalPerRadian2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="n">OpenMM</span><span class="o">::</span><span class="n">KJPerKcal</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Create the 1-2-3-4 bond torsion (dihedral) terms.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">torsions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">EndOfList</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w">         </span><span class="n">atom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">torsions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">atoms</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">TorsionType</span><span class="o">&amp;</span><span class="w"> </span><span class="n">torsion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">torsionType</span><span class="p">[</span><span class="n">torsions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">bondTorsion</span><span class="p">.</span><span class="n">addTorsion</span><span class="p">(</span><span class="n">atom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">atom</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">atom</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">atom</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"></span>
<span class="w">            </span><span class="n">torsion</span><span class="p">.</span><span class="n">periodicity</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">torsion</span><span class="p">.</span><span class="n">phaseInDegrees</span><span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">RadiansPerDegree</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">torsion</span><span class="p">.</span><span class="n">amplitudeInKcal</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">OpenMM</span><span class="o">::</span><span class="n">KJPerKcal</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The rest of the code is similar to the HelloSodiumChloride example and will not
be covered in detail here.  Please refer to the program HelloEthane.cpp itself,
which is well-commented, for additional details.</p>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="02_compiling.html" title="Previous document"><span class="section-number">8. </span>Compiling OpenMM from Source Code</a>
        </li>
        <li>
          <a href="04_platform_specifics.html" title="Next document"><span class="section-number">10. </span>Platform-Specific Properties</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.png" alt="Logo"/>
    
    <h1 class="logo logo-name">OpenMM User Guide</h1>
    
  </a>
</p>











<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script><div class="navigation-scrollbox">
    <div class="nav-toctree">
    <ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">1. Introduction</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../application.html">Part I: The OpenMM Application Layer</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../library.html">Part II: The OpenMM Library</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="01_introduction.html">7. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="02_compiling.html">8. Compiling OpenMM from Source Code</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="03_tutorials.html#">9. OpenMM Tutorials</a><ul>
<li class="toctree-l3"><a class="reference internal" href="03_tutorials.html#example-files-overview">9.1. Example Files Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="03_tutorials.html#running-example-files">9.2. Running Example Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="03_tutorials.html#helloargon-program">9.3. HelloArgon Program</a></li>
<li class="toctree-l3"><a class="reference internal" href="03_tutorials.html#hellosodiumchloride-program">9.4. HelloSodiumChloride Program</a></li>
<li class="toctree-l3"><a class="reference internal" href="03_tutorials.html#helloethane-program">9.5. HelloEthane Program</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="04_platform_specifics.html">10. Platform-Specific Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="05_languages_not_cpp.html">11. Using OpenMM with Software Written in Languages Other than C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="06_integration_examples.html">12. Examples of OpenMM Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="07_testing_validation.html">13. Testing and Validation of OpenMM</a></li>
<li class="toctree-l2"><a class="reference internal" href="08_amoeba_plugin.html">14. AMOEBA Plugin</a></li>
<li class="toctree-l2"><a class="reference internal" href="09_rpmd_plugin.html">15. Ring Polymer Molecular Dynamics (RPMD) Plugin</a></li>
<li class="toctree-l2"><a class="reference internal" href="10_drude_plugin.html">16. Drude Plugin</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../theory.html">Part III: The Theory Behind OpenMM</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zbibliography.html">22. Bibliography</a></li>
</ul>

    </div>
    
    <ul class="extra-nav-links">
        
        <li class="toctree-l1">
            <a href="https://openmm.org">
                OpenMM.org
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="http://docs.openmm.org/7.7.0/developerguide/">
                Developer Guide
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="http://docs.openmm.org/7.7.0/api-python/">
                Python API reference
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="http://docs.openmm.org/7.7.0/api-c++/">
                C++ API reference
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://github.com/openmm">
                GitHub
            </a>
        </li>
        
    </ul>
    
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2008-2017, Stanford University.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/library/03_tutorials.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>