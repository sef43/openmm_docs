
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>AmoebaMultipoleForce &#8212; OpenMM Python API c2d2539933259d85365b465b39e6c3113559e016 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="AmoebaTorsionTorsionForce" href="openmm.openmm.AmoebaTorsionTorsionForce.html" />
    <link rel="prev" title="AmoebaGeneralizedKirkwoodForce" href="openmm.openmm.AmoebaGeneralizedKirkwoodForce.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="amoebamultipoleforce">
<h1>AmoebaMultipoleForce<a class="headerlink" href="#amoebamultipoleforce" title="Permalink to this heading">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">openmm.openmm.</span></span><span class="sig-name descname"><span class="pre">AmoebaMultipoleForce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce" title="Permalink to this definition">¶</a></dt>
<dd><p>This class implements the Amoeba multipole interaction.</p>
<p>To use it, create an AmoebaMultipoleForce object then call addMultipole() once for each atom. After an entry has been added, you can modify its force field parameters by calling setMultipoleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext().</p>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce" title="openmm.openmm.AmoebaMultipoleForce"><span class="pre">AmoebaMultipoleForce</span></a></span></span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.__init__" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce" title="openmm.openmm.AmoebaMultipoleForce"><span class="pre">AmoebaMultipoleForce</span></a></span></span></dt>
<dd><p>Create an AmoebaMultipoleForce.</p>
</dd></dl>

<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.__init__" title="openmm.openmm.AmoebaMultipoleForce.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code></a>(-&gt; AmoebaMultipoleForce)</p></td>
<td><p>Create an AmoebaMultipoleForce.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.addMultipole" title="openmm.openmm.AmoebaMultipoleForce.addMultipole"><code class="xref py py-obj docutils literal notranslate"><span class="pre">addMultipole</span></code></a>(self, charge, molecularDipole, ...)</p></td>
<td><p>Add multipole-related info for a particle</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getAEwald" title="openmm.openmm.AmoebaMultipoleForce.getAEwald"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getAEwald</span></code></a>(self)</p></td>
<td><p>Get the Ewald alpha parameter.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getCovalentMap" title="openmm.openmm.AmoebaMultipoleForce.getCovalentMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getCovalentMap</span></code></a>(self, index, typeId)</p></td>
<td><p>Get the CovalentMap for an atom</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getCovalentMaps" title="openmm.openmm.AmoebaMultipoleForce.getCovalentMaps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getCovalentMaps</span></code></a>(self, index)</p></td>
<td><p>Get the CovalentMap for an atom</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getCutoffDistance" title="openmm.openmm.AmoebaMultipoleForce.getCutoffDistance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getCutoffDistance</span></code></a>(self)</p></td>
<td><p>Get the cutoff distance (in nm) being used for nonbonded interactions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getElectrostaticPotential" title="openmm.openmm.AmoebaMultipoleForce.getElectrostaticPotential"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getElectrostaticPotential</span></code></a>(self, inputGrid, ...)</p></td>
<td><p>Get the electrostatic potential.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getEwaldErrorTolerance" title="openmm.openmm.AmoebaMultipoleForce.getEwaldErrorTolerance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getEwaldErrorTolerance</span></code></a>(self)</p></td>
<td><p>Get the error tolerance for Ewald summation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getExtrapolationCoefficients" title="openmm.openmm.AmoebaMultipoleForce.getExtrapolationCoefficients"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getExtrapolationCoefficients</span></code></a>(self)</p></td>
<td><p>Get the coefficients for the mu_0, mu_1, mu_2, ..., mu_n terms in the extrapolation algorithm for induced dipoles.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getForceGroup" title="openmm.openmm.AmoebaMultipoleForce.getForceGroup"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getForceGroup</span></code></a>(self)</p></td>
<td><p>Get the force group this Force belongs to.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getInducedDipoles" title="openmm.openmm.AmoebaMultipoleForce.getInducedDipoles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getInducedDipoles</span></code></a>(self, context)</p></td>
<td><p>Get the induced dipole moments of all particles.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getLabFramePermanentDipoles" title="openmm.openmm.AmoebaMultipoleForce.getLabFramePermanentDipoles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getLabFramePermanentDipoles</span></code></a>(self, context)</p></td>
<td><p>Get the fixed dipole moments of all particles in the global reference frame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getMultipoleParameters" title="openmm.openmm.AmoebaMultipoleForce.getMultipoleParameters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getMultipoleParameters</span></code></a>(self, index)</p></td>
<td><p>Get the multipole parameters for a particle.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getMutualInducedMaxIterations" title="openmm.openmm.AmoebaMultipoleForce.getMutualInducedMaxIterations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getMutualInducedMaxIterations</span></code></a>(self)</p></td>
<td><p>Get the max number of iterations to be used in calculating the mutual induced dipoles</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getMutualInducedTargetEpsilon" title="openmm.openmm.AmoebaMultipoleForce.getMutualInducedTargetEpsilon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getMutualInducedTargetEpsilon</span></code></a>(self)</p></td>
<td><p>Get the target epsilon to be used to test for convergence of iterative method used in calculating the mutual induced dipoles</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getName" title="openmm.openmm.AmoebaMultipoleForce.getName"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getName</span></code></a>(self)</p></td>
<td><p>Get the name of this Force.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getNonbondedMethod" title="openmm.openmm.AmoebaMultipoleForce.getNonbondedMethod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getNonbondedMethod</span></code></a>(self)</p></td>
<td><p>Get the method used for handling long-range nonbonded interactions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getNumMultipoles" title="openmm.openmm.AmoebaMultipoleForce.getNumMultipoles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getNumMultipoles</span></code></a>(self)</p></td>
<td><p>Get the number of particles in the potential function</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getPMEParameters" title="openmm.openmm.AmoebaMultipoleForce.getPMEParameters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getPMEParameters</span></code></a>(self)</p></td>
<td><p>Get the parameters to use for PME calculations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getPMEParametersInContext" title="openmm.openmm.AmoebaMultipoleForce.getPMEParametersInContext"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getPMEParametersInContext</span></code></a>(self, context)</p></td>
<td><p>Get the parameters being used for PME in a particular Context.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getPmeBSplineOrder" title="openmm.openmm.AmoebaMultipoleForce.getPmeBSplineOrder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getPmeBSplineOrder</span></code></a>(self)</p></td>
<td><p>Get the B-spline order to use for PME charge spreading</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getPmeGridDimensions" title="openmm.openmm.AmoebaMultipoleForce.getPmeGridDimensions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getPmeGridDimensions</span></code></a>(self)</p></td>
<td><p>Get the PME grid dimensions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getPolarizationType" title="openmm.openmm.AmoebaMultipoleForce.getPolarizationType"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getPolarizationType</span></code></a>(self)</p></td>
<td><p>Get polarization type</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getSystemMultipoleMoments" title="openmm.openmm.AmoebaMultipoleForce.getSystemMultipoleMoments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getSystemMultipoleMoments</span></code></a>(self, context)</p></td>
<td><p>Get the system multipole moments.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.getTotalDipoles" title="openmm.openmm.AmoebaMultipoleForce.getTotalDipoles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getTotalDipoles</span></code></a>(self, context)</p></td>
<td><p>Get the total dipole moments (fixed plus induced) of all particles.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.setAEwald" title="openmm.openmm.AmoebaMultipoleForce.setAEwald"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setAEwald</span></code></a>(self, aewald)</p></td>
<td><p>Set the Ewald alpha parameter.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.setCovalentMap" title="openmm.openmm.AmoebaMultipoleForce.setCovalentMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setCovalentMap</span></code></a>(self, index, typeId, ...)</p></td>
<td><p>Set the CovalentMap for an atom</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.setCutoffDistance" title="openmm.openmm.AmoebaMultipoleForce.setCutoffDistance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setCutoffDistance</span></code></a>(self, distance)</p></td>
<td><p>Set the cutoff distance (in nm) being used for nonbonded interactions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.setEwaldErrorTolerance" title="openmm.openmm.AmoebaMultipoleForce.setEwaldErrorTolerance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setEwaldErrorTolerance</span></code></a>(self, tol)</p></td>
<td><p>Get the error tolerance for Ewald summation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.setExtrapolationCoefficients" title="openmm.openmm.AmoebaMultipoleForce.setExtrapolationCoefficients"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setExtrapolationCoefficients</span></code></a>(self, coefficients)</p></td>
<td><p>Set the coefficients for the mu_0, mu_1, mu_2, ..., mu_n terms in the extrapolation algorithm for induced dipoles.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.setForceGroup" title="openmm.openmm.AmoebaMultipoleForce.setForceGroup"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setForceGroup</span></code></a>(self, group)</p></td>
<td><p>Set the force group this Force belongs to.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.setMultipoleParameters" title="openmm.openmm.AmoebaMultipoleForce.setMultipoleParameters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setMultipoleParameters</span></code></a>(self, index, charge, ...)</p></td>
<td><p>Set the multipole parameters for a particle.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.setMutualInducedMaxIterations" title="openmm.openmm.AmoebaMultipoleForce.setMutualInducedMaxIterations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setMutualInducedMaxIterations</span></code></a>(self, ...)</p></td>
<td><p>Set the max number of iterations to be used in calculating the mutual induced dipoles</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.setMutualInducedTargetEpsilon" title="openmm.openmm.AmoebaMultipoleForce.setMutualInducedTargetEpsilon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setMutualInducedTargetEpsilon</span></code></a>(self, ...)</p></td>
<td><p>Set the target epsilon to be used to test for convergence of iterative method used in calculating the mutual induced dipoles</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.setName" title="openmm.openmm.AmoebaMultipoleForce.setName"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setName</span></code></a>(self, name)</p></td>
<td><p>Set the name of this Force.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.setNonbondedMethod" title="openmm.openmm.AmoebaMultipoleForce.setNonbondedMethod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setNonbondedMethod</span></code></a>(self, method)</p></td>
<td><p>Set the method used for handling long-range nonbonded interactions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.setPMEParameters" title="openmm.openmm.AmoebaMultipoleForce.setPMEParameters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setPMEParameters</span></code></a>(self, alpha, nx, ny, nz)</p></td>
<td><p>Set the parameters to use for PME calculations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.setPmeGridDimensions" title="openmm.openmm.AmoebaMultipoleForce.setPmeGridDimensions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setPmeGridDimensions</span></code></a>(self, gridDimension)</p></td>
<td><p>Set the PME grid dimensions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.setPolarizationType" title="openmm.openmm.AmoebaMultipoleForce.setPolarizationType"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setPolarizationType</span></code></a>(self, type)</p></td>
<td><p>Set the polarization type</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.updateParametersInContext" title="openmm.openmm.AmoebaMultipoleForce.updateParametersInContext"><code class="xref py py-obj docutils literal notranslate"><span class="pre">updateParametersInContext</span></code></a>(self, context)</p></td>
<td><p>Update the multipole parameters in a Context to match those stored in this Force object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.usesPeriodicBoundaryConditions" title="openmm.openmm.AmoebaMultipoleForce.usesPeriodicBoundaryConditions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">usesPeriodicBoundaryConditions</span></code></a>(self)</p></td>
<td><p>Returns whether or not this force makes use of periodic boundary conditions.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Bisector</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Covalent12</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Covalent13</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Covalent14</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Covalent15</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">CovalentEnd</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Direct</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Extrapolated</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">LastAxisTypeIndex</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Mutual</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">NoAxisType</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">NoCutoff</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PME</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PolarizationCovalent11</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PolarizationCovalent12</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PolarizationCovalent13</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">PolarizationCovalent14</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ThreeFold</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ZBisect</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ZOnly</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ZThenX</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.AmoebaMultipoleForce.thisown" title="openmm.openmm.AmoebaMultipoleForce.thisown"><code class="xref py py-obj docutils literal notranslate"><span class="pre">thisown</span></code></a></p></td>
<td><p>The membership flag</p></td>
</tr>
</tbody>
</table>
<dl class="py property">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.thisown">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">thisown</span></span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.thisown" title="Permalink to this definition">¶</a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getNumMultipoles">
<span class="sig-name descname"><span class="pre">getNumMultipoles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getNumMultipoles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of particles in the potential function</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getNonbondedMethod">
<span class="sig-name descname"><span class="pre">getNonbondedMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">OpenMM::AmoebaMultipoleForce::NonbondedMethod</span></span></span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getNonbondedMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the method used for handling long-range nonbonded interactions.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.setNonbondedMethod">
<span class="sig-name descname"><span class="pre">setNonbondedMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.setNonbondedMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the method used for handling long-range nonbonded interactions.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getPolarizationType">
<span class="sig-name descname"><span class="pre">getPolarizationType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">OpenMM::AmoebaMultipoleForce::PolarizationType</span></span></span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getPolarizationType" title="Permalink to this definition">¶</a></dt>
<dd><p>Get polarization type</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.setPolarizationType">
<span class="sig-name descname"><span class="pre">setPolarizationType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.setPolarizationType" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the polarization type</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getCutoffDistance">
<span class="sig-name descname"><span class="pre">getCutoffDistance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">double</span></span></span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getCutoffDistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the cutoff distance, measured in nm</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>double</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.setCutoffDistance">
<span class="sig-name descname"><span class="pre">setCutoffDistance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.setCutoffDistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>distance</strong> (<em>double</em>) – the cutoff distance, measured in nm</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getPMEParameters">
<span class="sig-name descname"><span class="pre">getPMEParameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getPMEParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the parameters to use for PME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>alpha</strong> (<em>double</em>) – the separation parameter</p></li>
<li><p><strong>nx</strong> (<em>int</em>) – the number of grid points along the X axis</p></li>
<li><p><strong>ny</strong> (<em>int</em>) – the number of grid points along the Y axis</p></li>
<li><p><strong>nz</strong> (<em>int</em>) – the number of grid points along the Z axis</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.setPMEParameters">
<span class="sig-name descname"><span class="pre">setPMEParameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ny</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nz</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.setPMEParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters to use for PME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha</strong> (<em>double</em>) – the separation parameter</p></li>
<li><p><strong>nx</strong> (<em>int</em>) – the number of grid points along the X axis</p></li>
<li><p><strong>ny</strong> (<em>int</em>) – the number of grid points along the Y axis</p></li>
<li><p><strong>nz</strong> (<em>int</em>) – the number of grid points along the Z axis</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getAEwald">
<span class="sig-name descname"><span class="pre">getAEwald</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">double</span></span></span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getAEwald" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Ewald alpha parameter. If this is 0 (the default), a value is chosen automatically based on the Ewald error tolerance.</p>
<div class="admonition-deprecated admonition">
<p class="admonition-title">Deprecated</p>
<blockquote>
<div><p>This method exists only for backward compatibility. Use getPMEParameters() instead.</p>
</div></blockquote>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the Ewald alpha parameter</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>double</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.setAEwald">
<span class="sig-name descname"><span class="pre">setAEwald</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aewald</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.setAEwald" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the Ewald alpha parameter. If this is 0 (the default), a value is chosen automatically based on the Ewald error tolerance.</p>
<div class="admonition-deprecated admonition">
<p class="admonition-title">Deprecated</p>
<blockquote>
<div><p>This method exists only for backward compatibility. Use setPMEParameters() instead.</p>
</div></blockquote>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>aewald</strong> (<em>double</em>) – alpha parameter</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getPmeBSplineOrder">
<span class="sig-name descname"><span class="pre">getPmeBSplineOrder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getPmeBSplineOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the B-spline order to use for PME charge spreading</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the B-spline order</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getPmeGridDimensions">
<span class="sig-name descname"><span class="pre">getPmeGridDimensions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getPmeGridDimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the PME grid dimensions. If Ewald alpha is 0 (the default), this is ignored and grid dimensions are chosen automatically based on the Ewald error tolerance.</p>
<div class="admonition-deprecated admonition">
<p class="admonition-title">Deprecated</p>
<blockquote>
<div><p>This method exists only for backward compatibility. Use getPMEParameters() instead.</p>
</div></blockquote>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the PME grid dimensions</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>void</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.setPmeGridDimensions">
<span class="sig-name descname"><span class="pre">setPmeGridDimensions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gridDimension</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.setPmeGridDimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the PME grid dimensions. If Ewald alpha is 0 (the default), this is ignored and grid dimensions are chosen automatically based on the Ewald error tolerance.</p>
<div class="admonition-deprecated admonition">
<p class="admonition-title">Deprecated</p>
<blockquote>
<div><p>This method exists only for backward compatibility. Use setPMEParameters() instead.</p>
</div></blockquote>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>gridDimension</strong> (<em>vector&lt; int &gt;</em>) – the PME grid dimensions</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getPMEParametersInContext">
<span class="sig-name descname"><span class="pre">getPMEParametersInContext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getPMEParametersInContext" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the parameters being used for PME in a particular Context. Because some platforms have restrictions on the allowed grid sizes, the values that are actually used may be slightly different from those specified with setPmeGridDimensions(), or the standard values calculated based on the Ewald error tolerance. See the manual for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>context</strong> (<a class="reference internal" href="openmm.openmm.Context.html#openmm.openmm.Context" title="openmm.openmm.Context"><em>Context</em></a>) – the Context for which to get the parameters</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>alpha</strong> (<em>double</em>) – the separation parameter</p></li>
<li><p><strong>nx</strong> (<em>int</em>) – the number of grid points along the X axis</p></li>
<li><p><strong>ny</strong> (<em>int</em>) – the number of grid points along the Y axis</p></li>
<li><p><strong>nz</strong> (<em>int</em>) – the number of grid points along the Z axis</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.addMultipole">
<span class="sig-name descname"><span class="pre">addMultipole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">charge</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">molecularDipole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">molecularQuadrupole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axisType</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multipoleAtomZ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multipoleAtomX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multipoleAtomY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dampingFactor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polarity</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.addMultipole" title="Permalink to this definition">¶</a></dt>
<dd><p>Add multipole-related info for a particle</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>charge</strong> (<em>double</em>) – the particle’s charge</p></li>
<li><p><strong>molecularDipole</strong> (<em>vector&lt; double &gt;</em>) – the particle’s molecular dipole (vector of size 3)</p></li>
<li><p><strong>molecularQuadrupole</strong> (<em>vector&lt; double &gt;</em>) – the particle’s molecular quadrupole (vector of size 9)</p></li>
<li><p><strong>axisType</strong> (<em>int</em>) – the particle’s axis type</p></li>
<li><p><strong>multipoleAtomZ</strong> (<em>int</em>) – index of first atom used in constructing lab&lt;-&gt;molecular frames</p></li>
<li><p><strong>multipoleAtomX</strong> (<em>int</em>) – index of second atom used in constructing lab&lt;-&gt;molecular frames</p></li>
<li><p><strong>multipoleAtomY</strong> (<em>int</em>) – index of second atom used in constructing lab&lt;-&gt;molecular frames</p></li>
<li><p><strong>thole</strong> (<em>double</em>) – Thole parameter</p></li>
<li><p><strong>dampingFactor</strong> (<em>double</em>) – dampingFactor parameter</p></li>
<li><p><strong>polarity</strong> (<em>double</em>) – polarity parameter</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the index of the particle that was added</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getMultipoleParameters">
<span class="sig-name descname"><span class="pre">getMultipoleParameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getMultipoleParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the multipole parameters for a particle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>index</strong> (<em>int</em>) – the index of the atom for which to get parameters</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>charge</strong> (<em>double</em>) – the particle’s charge</p></li>
<li><p><strong>molecularDipole</strong> (<em>vector&lt; double &gt;</em>) – the particle’s molecular dipole (vector of size 3)</p></li>
<li><p><strong>molecularQuadrupole</strong> (<em>vector&lt; double &gt;</em>) – the particle’s molecular quadrupole (vector of size 9)</p></li>
<li><p><strong>axisType</strong> (<em>int</em>) – the particle’s axis type</p></li>
<li><p><strong>multipoleAtomZ</strong> (<em>int</em>) – index of first atom used in constructing lab&lt;-&gt;molecular frames</p></li>
<li><p><strong>multipoleAtomX</strong> (<em>int</em>) – index of second atom used in constructing lab&lt;-&gt;molecular frames</p></li>
<li><p><strong>multipoleAtomY</strong> (<em>int</em>) – index of second atom used in constructing lab&lt;-&gt;molecular frames</p></li>
<li><p><strong>thole</strong> (<em>double</em>) – Thole parameter</p></li>
<li><p><strong>dampingFactor</strong> (<em>double</em>) – dampingFactor parameter</p></li>
<li><p><strong>polarity</strong> (<em>double</em>) – polarity parameter</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.setMultipoleParameters">
<span class="sig-name descname"><span class="pre">setMultipoleParameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">charge</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">molecularDipole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">molecularQuadrupole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axisType</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multipoleAtomZ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multipoleAtomX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multipoleAtomY</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dampingFactor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polarity</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.setMultipoleParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the multipole parameters for a particle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> (<em>int</em>) – the index of the atom for which to set parameters</p></li>
<li><p><strong>charge</strong> (<em>double</em>) – the particle’s charge</p></li>
<li><p><strong>molecularDipole</strong> (<em>vector&lt; double &gt;</em>) – the particle’s molecular dipole (vector of size 3)</p></li>
<li><p><strong>molecularQuadrupole</strong> (<em>vector&lt; double &gt;</em>) – the particle’s molecular quadrupole (vector of size 9)</p></li>
<li><p><strong>axisType</strong> (<em>int</em>) – the particle’s axis type</p></li>
<li><p><strong>multipoleAtomZ</strong> (<em>int</em>) – index of first atom used in constructing lab&lt;-&gt;molecular frames</p></li>
<li><p><strong>multipoleAtomX</strong> (<em>int</em>) – index of second atom used in constructing lab&lt;-&gt;molecular frames</p></li>
<li><p><strong>multipoleAtomY</strong> (<em>int</em>) – index of second atom used in constructing lab&lt;-&gt;molecular frames</p></li>
<li><p><strong>thole</strong> (<em>double</em>) – thole parameter</p></li>
<li><p><strong>dampingFactor</strong> (<em>double</em>) – damping factor parameter</p></li>
<li><p><strong>polarity</strong> (<em>double</em>) – polarity parameter</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.setCovalentMap">
<span class="sig-name descname"><span class="pre">setCovalentMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">typeId</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covalentAtoms</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.setCovalentMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the CovalentMap for an atom</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> (<em>int</em>) – the index of the atom for which to set parameters</p></li>
<li><p><strong>typeId</strong> (<em>CovalentType</em>) – CovalentTypes type</p></li>
<li><p><strong>covalentAtoms</strong> (<em>vector&lt; int &gt;</em>) – vector of covalent atoms associated w/ the specfied CovalentType</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getCovalentMap">
<span class="sig-name descname"><span class="pre">getCovalentMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">typeId</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getCovalentMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the CovalentMap for an atom</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> (<em>int</em>) – the index of the atom for which to set parameters</p></li>
<li><p><strong>typeId</strong> (<em>CovalentType</em>) – CovalentTypes type</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>covalentAtoms</strong> – output vector of covalent atoms associated w/ the specfied CovalentType</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>vector&lt; int &gt;</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getCovalentMaps">
<span class="sig-name descname"><span class="pre">getCovalentMaps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getCovalentMaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the CovalentMap for an atom</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>index</strong> (<em>int</em>) – the index of the atom for which to set parameters</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>covalentLists</strong> – output vector of covalent lists of atoms</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>vector&lt; std::vector&lt; int &gt; &gt;</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getMutualInducedMaxIterations">
<span class="sig-name descname"><span class="pre">getMutualInducedMaxIterations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getMutualInducedMaxIterations" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the max number of iterations to be used in calculating the mutual induced dipoles</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>max number of iterations</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.setMutualInducedMaxIterations">
<span class="sig-name descname"><span class="pre">setMutualInducedMaxIterations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inputMutualInducedMaxIterations</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.setMutualInducedMaxIterations" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the max number of iterations to be used in calculating the mutual induced dipoles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>inputMutualInducedMaxIterations</strong> (<em>int</em>) – number of iterations</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getMutualInducedTargetEpsilon">
<span class="sig-name descname"><span class="pre">getMutualInducedTargetEpsilon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">double</span></span></span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getMutualInducedTargetEpsilon" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the target epsilon to be used to test for convergence of iterative method used in calculating the mutual induced dipoles</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>target epsilon</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>double</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.setMutualInducedTargetEpsilon">
<span class="sig-name descname"><span class="pre">setMutualInducedTargetEpsilon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inputMutualInducedTargetEpsilon</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.setMutualInducedTargetEpsilon" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the target epsilon to be used to test for convergence of iterative method used in calculating the mutual induced dipoles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>inputMutualInducedTargetEpsilon</strong> (<em>double</em>) – target epsilon</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.setExtrapolationCoefficients">
<span class="sig-name descname"><span class="pre">setExtrapolationCoefficients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.setExtrapolationCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the coefficients for the mu_0, mu_1, mu_2, …, mu_n terms in the extrapolation algorithm for induced dipoles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coefficients</strong> (<em>vector&lt; double &gt;</em>) – a vector whose mth entry specifies the coefficient for mu_m. The length of this vector determines how many iterations are performed.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getExtrapolationCoefficients">
<span class="sig-name descname"><span class="pre">getExtrapolationCoefficients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">vectord</span></span></span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getExtrapolationCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the coefficients for the mu_0, mu_1, mu_2, …, mu_n terms in the extrapolation algorithm for induced dipoles. In this release, the default values for the coefficients are [-0.154, 0.017, 0.658, 0.474], but be aware that those may change in a future release.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getEwaldErrorTolerance">
<span class="sig-name descname"><span class="pre">getEwaldErrorTolerance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">double</span></span></span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getEwaldErrorTolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the grid dimensions and separation (alpha) parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however.</p>
<p>This can be overridden by explicitly setting an alpha parameter and grid dimensions to use.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.setEwaldErrorTolerance">
<span class="sig-name descname"><span class="pre">setEwaldErrorTolerance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.setEwaldErrorTolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the grid dimensions and separation (alpha) parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however.</p>
<p>This can be overridden by explicitly setting an alpha parameter and grid dimensions to use.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getLabFramePermanentDipoles">
<span class="sig-name descname"><span class="pre">getLabFramePermanentDipoles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getLabFramePermanentDipoles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the fixed dipole moments of all particles in the global reference frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>context</strong> (<a class="reference internal" href="openmm.openmm.Context.html#openmm.openmm.Context" title="openmm.openmm.Context"><em>Context</em></a>) – the Context for which to get the fixed dipoles</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>dipoles</strong> – the fixed dipole moment of particle i is stored into the i’th element</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>vector&lt; Vec3 &gt;</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getInducedDipoles">
<span class="sig-name descname"><span class="pre">getInducedDipoles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getInducedDipoles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the induced dipole moments of all particles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>context</strong> (<a class="reference internal" href="openmm.openmm.Context.html#openmm.openmm.Context" title="openmm.openmm.Context"><em>Context</em></a>) – the Context for which to get the induced dipoles</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>dipoles</strong> – the induced dipole moment of particle i is stored into the i’th element</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>vector&lt; Vec3 &gt;</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getTotalDipoles">
<span class="sig-name descname"><span class="pre">getTotalDipoles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getTotalDipoles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the total dipole moments (fixed plus induced) of all particles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>context</strong> (<a class="reference internal" href="openmm.openmm.Context.html#openmm.openmm.Context" title="openmm.openmm.Context"><em>Context</em></a>) – the Context for which to get the total dipoles</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>dipoles</strong> – the total dipole moment of particle i is stored into the i’th element</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>vector&lt; Vec3 &gt;</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getElectrostaticPotential">
<span class="sig-name descname"><span class="pre">getElectrostaticPotential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inputGrid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getElectrostaticPotential" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the electrostatic potential.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputGrid</strong> (<em>vector&lt; Vec3 &gt;</em>) – input grid points over which the potential is to be evaluated</p></li>
<li><p><strong>context</strong> (<a class="reference internal" href="openmm.openmm.Context.html#openmm.openmm.Context" title="openmm.openmm.Context"><em>Context</em></a>) – context</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>outputElectrostaticPotential</strong> – output potential</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>vector&lt; double &gt;</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getSystemMultipoleMoments">
<span class="sig-name descname"><span class="pre">getSystemMultipoleMoments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getSystemMultipoleMoments" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the system multipole moments.</p>
<p>This method is most useful for non-periodic systems. When called for a periodic system, only the <em>lowest nonvanishing moment</em> has a well defined value. This means that if the system has a net nonzero charge, the dipole and quadrupole moments are not well defined and should be ignored. If the net charge is zero, the dipole moment is well defined (and really represents a dipole density), but the quadrupole moment is still undefined and should be ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>context</strong> (<a class="reference internal" href="openmm.openmm.Context.html#openmm.openmm.Context" title="openmm.openmm.Context"><em>Context</em></a>) – context</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>outputMultipoleMoments</strong> – (charge, dipole_x, dipole_y, dipole_z, quadrupole_xx, quadrupole_xy, quadrupole_xz, quadrupole_yx, quadrupole_yy, quadrupole_yz, quadrupole_zx, quadrupole_zy, quadrupole_zz)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>vector&lt; double &gt;</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.updateParametersInContext">
<span class="sig-name descname"><span class="pre">updateParametersInContext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.updateParametersInContext" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the multipole parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setMultipoleParameters() to modify this object’s parameters, then call updateParametersInContext() to copy them over to the Context.</p>
<p>This method has several limitations. The only information it updates is the parameters of multipoles. All other aspects of the Force (the nonbonded method, the cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context. Furthermore, this method cannot be used to add new multipoles, only to change the parameters of existing ones.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.usesPeriodicBoundaryConditions">
<span class="sig-name descname"><span class="pre">usesPeriodicBoundaryConditions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.usesPeriodicBoundaryConditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether or not this force makes use of periodic boundary conditions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>true if nonbondedMethod uses PBC and false otherwise</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getForceGroup">
<span class="sig-name descname"><span class="pre">getForceGroup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getForceGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the force group this Force belongs to.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.getName">
<span class="sig-name descname"><span class="pre">getName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">std::string</span> <span class="pre">const</span> <span class="pre">&amp;</span></span></span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.getName" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.setForceGroup">
<span class="sig-name descname"><span class="pre">setForceGroup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.setForceGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the force group this Force belongs to.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>group</strong> (<em>int</em>) – the group index. Legal values are between 0 and 31 (inclusive).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.AmoebaMultipoleForce.setName">
<span class="sig-name descname"><span class="pre">setName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.AmoebaMultipoleForce.setName" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.</p>
</dd></dl>

</dd></dl>

</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="openmm.openmm.AmoebaGeneralizedKirkwoodForce.html" title="Previous document">AmoebaGeneralizedKirkwoodForce</a>
        </li>
        <li>
          <a href="openmm.openmm.AmoebaTorsionTorsionForce.html" title="Next document">AmoebaTorsionTorsionForce</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.png" alt="Logo"/>
    
    <h1 class="logo logo-name">OpenMM Python API</h1>
    
  </a>
</p>










<script>
function report(value) {
    newlink = "http://docs.openmm.org/"+value+"/api-python/";
    location.href = newlink;
}
</script>
<div class="extra-nav-links">
These docs are for <a href="https://github.com/openmm/openmm/tree/c2d2539933259d85365b465b39e6c3113559e016">OpenMM version = 8.0.0.dev-c2d2539</a>
</div>
<div class="extra-nav-links">
You can change to a different version:
<select name="version" id="version_selector" onchange="report(this.value)">
    <options selected disabled>version</option>
    <option>development</option>
    <option>latest</option>
    <option>7.7.0</option>
    <option>7.6.0</option>
    <option>7.5.0</option>
    <option>7.4.0</option>
    <option>7.3.0</option>
    <option>7.2.0</option>
    <option>7.1.0</option>
</select>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><div class="navigation-scrollbox">
    <div class="nav-toctree">
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../app.html">Application Layer</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../library.html">Library Layer</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../library.html#core-objects">Core Objects</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../library.html#forces">Forces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../library.html#integrators">Integrators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../library.html#extras">Extras</a></li>
</ul>
</li>
</ul>

    </div>
    
    <ul class="extra-nav-links">
        
        <li class="toctree-l1">
            <a href="https://openmm.org">
                OpenMM.org
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="../../userguide/">
                User's Manual
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="../../developerguide/">
                Developer Guide
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="../../api-c++/">
                C++ API reference
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://github.com/openmm">
                GitHub
            </a>
        </li>
        
    </ul>
    
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Stanford University and the Authors.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 6.1.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../_sources/generated/openmm.openmm.AmoebaMultipoleForce.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>