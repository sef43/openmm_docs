
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>11. Using OpenMM with Software Written in Languages Other than C++ &#8212; OpenMM User Guide c2d2539933259d85365b465b39e6c3113559e016 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="12. Examples of OpenMM Integration" href="06_integration_examples.html" />
    <link rel="prev" title="10. Platform-Specific Properties" href="04_platform_specifics.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="using-openmm-with-software-written-in-languages-other-than-c">
<span id="id1"></span><h1><span class="section-number">11. </span>Using OpenMM with Software Written in Languages Other than C++<a class="headerlink" href="#using-openmm-with-software-written-in-languages-other-than-c" title="Permalink to this heading">¶</a></h1>
<p>Although the native OpenMM API is object-oriented C++ code, it is possible to
directly translate the interface so that it is callable from C, Fortran 95, and
Python with no substantial conceptual changes. We have developed a
straightforward mapping for these languages that, while perhaps not the most
elegant possible, has several advantages:</p>
<ul class="simple">
<li><p>Almost all documentation, training, forum discussions, and so on are equally
useful to users of all these languages. There are syntactic differences of
course, but all the important concepts remain unchanged.</p></li>
<li><p>We are able to generate the C, Fortran, and Python APIs from the C++ API.
Obviously, this reduces development effort, but more importantly it means that
the APIs are likely to be error-free and are always available immediately when
the native API is updated.</p></li>
<li><p>Because OpenMM performs expensive operations “in bulk” there is no noticeable
overhead in accessing these operations through the C, Fortran, or Python APIs.</p></li>
<li><p>All symbols introduced to a C or Fortran program begin with the prefix
“<code class="code docutils literal notranslate"><span class="pre">OpenMM_</span></code>” so will not interfere with symbols already in use.</p></li>
</ul>
<p><em>Availability of APIs in other languages:</em>  All necessary C and Fortran
bindings are built in to the main OpenMM library; no separate library is
required.  The Python wrappers are contained in a module that is distributed
with OpenMM and that can be installed by executing its setup.py script in the
standard way.</p>
<p>(This doesn’t apply to most users: if you are building your own OpenMM from
source using CMake and want the API bindings generated, be sure to enable the
<code class="code docutils literal notranslate"><span class="pre">OPENMM_BUILD_C_AND_FORTRAN_WRAPPERS</span></code> option for C and Fortran, or
<code class="code docutils literal notranslate"><span class="pre">OPENMM_BUILD_PYTHON_WRAPPERS</span></code> option for Python.  The Python module
will be placed in a subdirectory of your main build directory called “python”)</p>
<p><em>Documentation for APIs in other languages:</em>  While there is extensive
Doxygen documentation available for the C++ and Python APIs, there is no
separate on-line documentation for the C and Fortran API. Instead, you should
use the C++ documentation, employing the mappings described here to figure out
the equivalent syntax in C or Fortran.</p>
<section id="c-api">
<h2><span class="section-number">11.1. </span>C API<a class="headerlink" href="#c-api" title="Permalink to this heading">¶</a></h2>
<p>Before you start writing your own C program that calls OpenMM, be sure you can
build and run the two C examples that are supplied with OpenMM (see Chapter <a class="reference internal" href="03_tutorials.html#openmm-tutorials"><span class="std std-numref">9</span></a>).
These can be built from the supplied <code class="code docutils literal notranslate"><span class="pre">Makefile</span></code> on Linux and Mac, or
supplied <code class="code docutils literal notranslate"><span class="pre">NMakefile</span></code> and Visual Studio solution files on Windows.</p>
<p>The example programs are <code class="code docutils literal notranslate"><span class="pre">HelloArgonInC</span></code> and
<code class="code docutils literal notranslate"><span class="pre">HelloSodiumChlorideInC</span></code>. The argon example serves as a quick check that
your installation is set up properly and you know how to build a C program that
is linked with OpenMM. It will also tell you whether OpenMM is executing on the
GPU or is running (slowly) on the Reference platform. However, the argon example
is not a good template to follow for your own programs. The sodium chloride
example, though necessarily simplified, is structured roughly in the way we
recommended you set up your own programs to call OpenMM. Please be sure you have
both of these programs executing successfully on your machine before continuing.</p>
<section id="mechanics-of-using-the-c-api">
<h3><span class="section-number">11.1.1. </span>Mechanics of using the C API<a class="headerlink" href="#mechanics-of-using-the-c-api" title="Permalink to this heading">¶</a></h3>
<p>The C API is generated automatically from the C++ API when OpenMM is built.
There are two resulting components: C bindings (functions to call), and C
declarations (in a header file). The C bindings are small <code class="code docutils literal notranslate"><span class="pre">extern</span></code>
(global) interface functions, one for every method of every OpenMM class, whose
signatures (name and arguments) are predictable from the class name and method
signatures. There are also “helper” types and functions provided for the few
cases in which the C++ behavior cannot be directly mapped into C. These
interface and helper functions are compiled in to the main OpenMM library so
there is nothing special you have to do to get access to them.</p>
<p>In the <code class="code docutils literal notranslate"><span class="pre">include</span></code> subdirectory of your OpenMM installation directory,
there is a machine-generated header file <code class="code docutils literal notranslate"><span class="pre">OpenMMCWrapper.h</span></code> that
should be #included in any C program that is to make calls to OpenMM functions.
That header contains declarations for all the OpenMM C interface functions and
related types. Note that if you follow our suggested structure, you will not
need to include this file in your <code class="code docutils literal notranslate"><span class="pre">main()</span></code> compilation unit but can
instead use it only in a local file that you write to provide a simple interface
to your existing code (see Chapter <a class="reference internal" href="03_tutorials.html#openmm-tutorials"><span class="std std-numref">9</span></a>).</p>
</section>
<section id="mapping-from-the-c-api-to-the-c-api">
<h3><span class="section-number">11.1.2. </span>Mapping from the C++ API to the C API<a class="headerlink" href="#mapping-from-the-c-api-to-the-c-api" title="Permalink to this heading">¶</a></h3>
<p>The automated generator of the C “wrappers” follows the translation strategy
shown in Table 11-1. The idea is that if you see the construct on the left in
the C++ API documentation, you should interpret it as the corresponding
construct on the right in C. Please look at the supplied example programs to see
how this is done in practice.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Construct</p></th>
<th class="head"><p>C++ API declaration</p></th>
<th class="head"><p>Equivalent in C API</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>namespace</p></td>
<td><p>OpenMM::</p></td>
<td><p>OpenMM_ (prefix)</p></td>
</tr>
<tr class="row-odd"><td><p>class</p></td>
<td><p>class OpenMM::ClassName</p></td>
<td><p>typedef OpenMM_ClassName</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>OpenMM::RadiansPerDeg</p></td>
<td><p>OpenMM_RadiansPerDeg (static constant)</p></td>
</tr>
<tr class="row-odd"><td><p>class enum</p></td>
<td><p>OpenMM::State::Positions</p></td>
<td><p>OpenMM_State_Positions</p></td>
</tr>
<tr class="row-even"><td><p>constructor</p></td>
<td><p>new OpenMM::ClassName()</p></td>
<td><div class="line-block">
<div class="line">OpenMM_ClassName* OpenMM_ClassName_create()</div>
<div class="line">(additional constructors are _create_2(), etc.)</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>destructor</p></td>
<td><div class="line-block">
<div class="line">OpenMM::ClassName* thing;</div>
<div class="line">delete thing;</div>
</div>
</td>
<td><div class="line-block">
<div class="line">OpenMM_ClassName* thing;</div>
<div class="line">OpenMM_ClassName_destroy(thing);</div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>class method</p></td>
<td><div class="line-block">
<div class="line">OpenMM::ClassName* thing;</div>
<div class="line">thing-&gt;method(args);</div>
</div>
</td>
<td><div class="line-block">
<div class="line">OpenMM_ClassName* thing;</div>
<div class="line">OpenMM_ClassName_method(thing, args)</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>Boolean (type &amp; constants)</p></td>
<td><div class="line-block">
<div class="line">bool</div>
<div class="line">true, false</div>
</div>
</td>
<td><div class="line-block">
<div class="line">OpenMM_Boolean</div>
<div class="line">OpenMM_True(1), OpenMM_False(0)</div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>string</p></td>
<td><p>std::string</p></td>
<td><p>char*</p></td>
</tr>
<tr class="row-odd"><td><p>3-vector</p></td>
<td><p>OpenMM::Vec3</p></td>
<td><p>typedef OpenMM_Vec3</p></td>
</tr>
<tr class="row-even"><td><p>arrays</p></td>
<td><div class="line-block">
<div class="line">std::vector&lt;std::string&gt;</div>
<div class="line">std::vector&lt;double&gt;</div>
<div class="line">std::vector&lt;Vec3&gt;</div>
<div class="line">std::vector&lt;std::pair&lt;int,int&gt;&gt;</div>
<div class="line">std::map&lt;std::string,double&gt;</div>
</div>
</td>
<td><div class="line-block">
<div class="line">typedef OpenMM_StringArray</div>
<div class="line">typedef OpenMM_DoubleArray</div>
<div class="line">typedef OpenMM_Vec3Array</div>
<div class="line">typedef OpenMM_BondArray</div>
<div class="line">typedef OpenMM_ParameterArray</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>Table 11-1: Default mapping of objects from the C++ API to the C API
There are some exceptions to the generic translation rules shown in the table;
they are enumerated in the next section. And because there are no C++ API
equivalents to the array types, they are described in detail below.</p>
</section>
<section id="exceptions">
<h3><span class="section-number">11.1.3. </span>Exceptions<a class="headerlink" href="#exceptions" title="Permalink to this heading">¶</a></h3>
<p>These two methods are handled somewhat differently in the C API than in the C++ API:</p>
<ul class="simple">
<li><p><strong>OpenMM::Context::getState()</strong> The C version,
<code class="code docutils literal notranslate"><span class="pre">OpenMM_Context_getState()</span></code>, returns a pointer to a heap allocated
<code class="code docutils literal notranslate"><span class="pre">OpenMM_State</span></code> object. You must then explicitly destroy this
<code class="code docutils literal notranslate"><span class="pre">State</span></code> object when you are done with it, by calling
<code class="code docutils literal notranslate"><span class="pre">OpenMM_State_destroy()</span></code>.</p></li>
<li><p><strong>OpenMM::Platform::loadPluginsFromDirectory()</strong> The C version
<code class="code docutils literal notranslate"><span class="pre">OpenMM_Platform_loadPluginsFromDirectory()</span></code> returns a heap-allocated
<code class="code docutils literal notranslate"><span class="pre">OpenMM_StringArray</span></code> object containing a list of all the file names
that were successfully loaded. You must then explicitly destroy this
<code class="code docutils literal notranslate"><span class="pre">StringArray</span></code> object when you are done with it. Do not ignore the return
value; if you do you’ll have a memory leak since the <code class="code docutils literal notranslate"><span class="pre">StringArray</span></code>
will still be allocated.</p></li>
</ul>
<p>(In the C++ API, the equivalent methods return references into existing memory
rather than new heap-allocated memory, so the returned objects do not need to be
destroyed.)</p>
</section>
<section id="openmm-vec3-helper-type">
<h3><span class="section-number">11.1.4. </span>OpenMM_Vec3 helper type<a class="headerlink" href="#openmm-vec3-helper-type" title="Permalink to this heading">¶</a></h3>
<p>Unlike the other OpenMM objects which are opaque and manipulated via pointers,
the C API provides an explicit definition for the C <code class="code docutils literal notranslate"><span class="pre">OpenMM_Vec3</span></code> type
that is compatible with the <code class="code docutils literal notranslate"><span class="pre">OpenMM::Vec3</span></code> type. The definition of
<code class="code docutils literal notranslate"><span class="pre">OpenMM_Vec3</span></code> is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">;}</span><span class="w"> </span><span class="n">OpenMM_Vec3</span><span class="p">;</span>
</pre></div>
</div>
<p>You can work directly with the individual fields of this type from your C
program if you want. For convenience, a scale() function is provided that
creates a new OpenMM_Vec3 from an old one and a scale factor:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">OpenMM_Vec3</span><span class="w"> </span><span class="nf">OpenMM_Vec3_scale</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OpenMM_Vec3</span><span class="w"> </span><span class="n">vec</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">scale</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="array-helper-types">
<h3><span class="section-number">11.1.5. </span>Array helper types<a class="headerlink" href="#array-helper-types" title="Permalink to this heading">¶</a></h3>
<p>C++ has built-in container types <code class="code docutils literal notranslate"><span class="pre">std::vector</span></code> and <code class="code docutils literal notranslate"><span class="pre">std::map</span></code>
which OpenMM uses to manipulate arrays of objects. These don’t have direct
equivalents in C, so we supply special array types for each kind of object for
which OpenMM creates containers. These are: string, double, Vec3, bond, and
parameter map. See Table 11-2 for the names of the C types for each of these
object arrays. Each of the array types provides these functions (prefixed by
<code class="code docutils literal notranslate"><span class="pre">OpenMM_</span></code> and the actual <em>Thing</em> name), with the syntax shown
conceptually since it differs slightly for each kind of object.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Operation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>Thing</em>Array* create(int size)</p></td>
<td><p>Create a heap-allocated array of <em>Things</em>, with space pre-allocated to hold <code class="code docutils literal notranslate"><span class="pre">size</span></code> of them. You can start at <code class="code docutils literal notranslate"><span class="pre">size==0</span></code> if you want since these arrays are dynamically resizeable.</p></td>
</tr>
<tr class="row-odd"><td><p>void destroy(<em>Thing</em>Array*)</p></td>
<td><p>Free the heap space that is currently in use for the passed-in array of <em>Things</em>.</p></td>
</tr>
<tr class="row-even"><td><p>int getSize(<em>Thing</em>Array*)</p></td>
<td><p>Return the current number of <em>Things</em> in this array. This means you can <code class="code docutils literal notranslate"><span class="pre">get()</span></code> and <code class="code docutils literal notranslate"><span class="pre">set()</span></code> elements up to <code class="code docutils literal notranslate"><span class="pre">getSize()-1</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>void resize(<em>Thing</em>Array*, int size)</p></td>
<td><p>Change the size of this array to the indicated value which may be smaller or larger than the current size. Existing elements remain in their same locations as long as they still fit.</p></td>
</tr>
<tr class="row-even"><td><p>void append(<em>Thing</em>Array*, <em>Thing</em>)</p></td>
<td><p>Add a <em>Thing</em> to the end of the array, increasing the array size by one. The precise syntax depends on the actual type of <em>Thing</em>; see below.</p></td>
</tr>
<tr class="row-odd"><td><p>void set(<em>Thing</em>Array*, int index, <em>Thing</em>)</p></td>
<td><p>Store a copy of <em>Thing</em> in the indicated element of the array (indexed from 0). The array must be of length at least <code class="code docutils literal notranslate"><span class="pre">index+1</span></code>; you can’t grow the array with this function.</p></td>
</tr>
<tr class="row-even"><td><p><em>Thing</em> get(<em>Thing</em>Array*, int index)</p></td>
<td><p>Retrieve a particular element from the array (indexed from 0). (For some Things the value is returned in arguments rather than as the function return.)</p></td>
</tr>
</tbody>
</table>
<p>Table 11-2: Generic description of array helper types</p>
<p>Here are the exact declarations with deviations from the generic description
noted, for each of the array types.</p>
<section id="openmm-doublearray">
<h4>OpenMM_DoubleArray<a class="headerlink" href="#openmm-doublearray" title="Permalink to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">OpenMM_DoubleArray</span><span class="o">*</span>
<span class="w">            </span><span class="nf">OpenMM_DoubleArray_create</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="kt">void</span><span class="w">        </span><span class="nf">OpenMM_DoubleArray_destroy</span><span class="p">(</span><span class="n">OpenMM_DoubleArray</span><span class="o">*</span><span class="p">);</span>
<span class="kt">int</span><span class="w">         </span><span class="nf">OpenMM_DoubleArray_getSize</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OpenMM_DoubleArray</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span><span class="w">        </span><span class="nf">OpenMM_DoubleArray_resize</span><span class="p">(</span><span class="n">OpenMM_DoubleArray</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="kt">void</span><span class="w">        </span><span class="nf">OpenMM_DoubleArray_append</span><span class="p">(</span><span class="n">OpenMM_DoubleArray</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="kt">void</span><span class="w">        </span><span class="nf">OpenMM_DoubleArray_set</span><span class="p">(</span><span class="n">OpenMM_DoubleArray</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="kt">double</span><span class="w">      </span><span class="nf">OpenMM_DoubleArray_get</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OpenMM_DoubleArray</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="openmm-stringarray">
<h4>OpenMM_StringArray<a class="headerlink" href="#openmm-stringarray" title="Permalink to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">OpenMM_StringArray</span><span class="o">*</span>
<span class="w">            </span><span class="nf">OpenMM_StringArray_create</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="kt">void</span><span class="w">        </span><span class="nf">OpenMM_StringArray_destroy</span><span class="p">(</span><span class="n">OpenMM_StringArray</span><span class="o">*</span><span class="p">);</span>
<span class="kt">int</span><span class="w">         </span><span class="nf">OpenMM_StringArray_getSize</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OpenMM_StringArray</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span><span class="w">        </span><span class="nf">OpenMM_StringArray_resize</span><span class="p">(</span><span class="n">OpenMM_StringArray</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="kt">void</span><span class="w">        </span><span class="nf">OpenMM_StringArray_append</span><span class="p">(</span><span class="n">OpenMM_StringArray</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">string</span><span class="p">);</span>
<span class="kt">void</span><span class="w">        </span><span class="nf">OpenMM_StringArray_set</span><span class="p">(</span><span class="n">OpenMM_StringArray</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">string</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">OpenMM_StringArray_get</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OpenMM_StringArray</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="openmm-vec3array">
<h4>OpenMM_Vec3Array<a class="headerlink" href="#openmm-vec3array" title="Permalink to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">OpenMM_Vec3Array</span><span class="o">*</span>
<span class="w">            </span><span class="nf">OpenMM_Vec3Array_create</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="kt">void</span><span class="w">        </span><span class="nf">OpenMM_Vec3Array_destroy</span><span class="p">(</span><span class="n">OpenMM_Vec3Array</span><span class="o">*</span><span class="p">);</span>
<span class="kt">int</span><span class="w">         </span><span class="nf">OpenMM_Vec3Array_getSize</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OpenMM_Vec3Array</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span><span class="w">        </span><span class="nf">OpenMM_Vec3Array_resize</span><span class="p">(</span><span class="n">OpenMM_Vec3Array</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="kt">void</span><span class="w">        </span><span class="nf">OpenMM_Vec3Array_append</span><span class="p">(</span><span class="n">OpenMM_Vec3Array</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">OpenMM_Vec3</span><span class="w"> </span><span class="n">vec</span><span class="p">);</span>
<span class="kt">void</span><span class="w">        </span><span class="nf">OpenMM_Vec3Array_set</span><span class="p">(</span><span class="n">OpenMM_Vec3Array</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">OpenMM_Vec3</span><span class="w"> </span><span class="n">vec</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">OpenMM_Vec3</span><span class="o">*</span>
<span class="w">            </span><span class="nf">OpenMM_Vec3Array_get</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OpenMM_Vec3Array</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="openmm-bondarray">
<h4>OpenMM_BondArray<a class="headerlink" href="#openmm-bondarray" title="Permalink to this heading">¶</a></h4>
<p>Note that bonds are specified by pairs of integers (the atom indices). The
<code class="code docutils literal notranslate"><span class="pre">get()</span></code> method returns those in a pair of final arguments rather than as
its functional return.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">OpenMM_BondArray</span><span class="o">*</span>
<span class="w">            </span><span class="nf">OpenMM_BondArray_create</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="kt">void</span><span class="w">        </span><span class="nf">OpenMM_BondArray_destroy</span><span class="p">(</span><span class="n">OpenMM_BondArray</span><span class="o">*</span><span class="p">);</span>
<span class="kt">int</span><span class="w">         </span><span class="nf">OpenMM_BondArray_getSize</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OpenMM_BondArray</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span><span class="w">        </span><span class="nf">OpenMM_BondArray_resize</span><span class="p">(</span><span class="n">OpenMM_BondArray</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="kt">void</span><span class="w">        </span><span class="nf">OpenMM_BondArray_append</span><span class="p">(</span><span class="n">OpenMM_BondArray</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">particle1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">particle2</span><span class="p">);</span>
<span class="kt">void</span><span class="w">        </span><span class="nf">OpenMM_BondArray_set</span><span class="p">(</span><span class="n">OpenMM_BondArray</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">particle1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">particle2</span><span class="p">);</span>
<span class="kt">void</span><span class="w">        </span><span class="nf">OpenMM_BondArray_get</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OpenMM_BondArray</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span>
<span class="w">                                 </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">particle1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">particle2</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="openmm-parameterarray">
<h4>OpenMM_ParameterArray<a class="headerlink" href="#openmm-parameterarray" title="Permalink to this heading">¶</a></h4>
<p>OpenMM returns references to internal <code class="code docutils literal notranslate"><span class="pre">ParameterArrays</span></code> but does not
support user-created <code class="code docutils literal notranslate"><span class="pre">ParameterArrays</span></code>, so only the <code class="code docutils literal notranslate"><span class="pre">get()</span></code>
and <code class="code docutils literal notranslate"><span class="pre">getSize()</span></code> functions are available. Also, note that since this is
actually a map rather than an array, the “index” is the <em>name</em> of the
parameter rather than its ordinal.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w">         </span><span class="nf">OpenMM_ParameterArray_getSize</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OpenMM_ParameterArray</span><span class="o">*</span><span class="p">);</span>
<span class="kt">double</span><span class="w">      </span><span class="nf">OpenMM_ParameterArray_get</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OpenMM_ParameterArray</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="fortran-95-api">
<h2><span class="section-number">11.2. </span>Fortran 95 API<a class="headerlink" href="#fortran-95-api" title="Permalink to this heading">¶</a></h2>
<p>Before you start writing your own Fortran program that calls OpenMM, be sure you
can build and run the two Fortran examples that are supplied with OpenMM (see
Chapter <a class="reference internal" href="03_tutorials.html#openmm-tutorials"><span class="std std-numref">9</span></a>). These can be built from the supplied <code class="code docutils literal notranslate"><span class="pre">Makefile</span></code> on Linux
and Mac, or supplied <code class="code docutils literal notranslate"><span class="pre">NMakefile</span></code> and Visual Studio solution files on
Windows.</p>
<p>The example programs are <code class="code docutils literal notranslate"><span class="pre">HelloArgonInFortran</span></code> and
<code class="code docutils literal notranslate"><span class="pre">HelloSodiumChlorideInFortran</span></code>. The argon example serves as a quick
check that your installation is set up properly and you know how to build a
Fortran program that is linked with OpenMM. It will also tell you whether OpenMM
is executing on the GPU or is running (slowly) on the Reference platform.
However, the argon example is not a good template to follow for your own
programs. The sodium chloride example, though necessarily simplified, is
structured roughly in the way we recommended you set up your own programs to
call OpenMM. Please be sure you have both of these programs executing
successfully on your machine before continuing.</p>
<section id="mechanics-of-using-the-fortran-api">
<h3><span class="section-number">11.2.1. </span>Mechanics of using the Fortran API<a class="headerlink" href="#mechanics-of-using-the-fortran-api" title="Permalink to this heading">¶</a></h3>
<p>The Fortran API is generated automatically from the C++ API when OpenMM is
built. There are two resulting components: Fortran bindings (subroutines to
call), and Fortran declarations of types and subroutines (in the form of a
Fortran 95 module file). The Fortran bindings are small interface subroutines,
one for every method of every OpenMM class, whose signatures (name and
arguments) are predictable from the class name and method signatures. There are
also “helper” types and subroutines provided for the few cases in which the C++
behavior cannot be directly mapped into Fortran. These interface and helper
subroutines are compiled in to the main OpenMM library so there is nothing
special you have to do to get access to them.</p>
<p>Because Fortran is case-insensitive, calls to Fortran subroutines (however
capitalized) are mapped by the compiler into all-lowercase or all-uppercase
names, and different compilers use different conventions. The automatically-generated
OpenMM Fortran “wrapper” subroutines, which are generated in C and
thus case-sensitive, are provided in two forms for compatibility with the
majority of Fortran compilers, including Intel Fortran and gfortran. The two
forms are: (1) all-lowercase with a trailing underscore, and (2) all-uppercase
without a trailing underscore. So regardless of the Fortran compiler you are
using, it should find a suitable subroutine to call in the main OpenMM library.</p>
<p>In the <code class="code docutils literal notranslate"><span class="pre">include</span></code> subdirectory of your OpenMM installation directory,
there is a machine-generated module file <code class="code docutils literal notranslate"><span class="pre">OpenMMFortranModule.f90</span></code>
that must be compiled along with any Fortran program that is to make calls to
OpenMM functions. (You can look at the <code class="code docutils literal notranslate"><span class="pre">Makefile</span></code> or Visual Studio
solution file provided with the OpenMM examples to see how to build a program
that uses this module file.) This module file contains definitions for two
modules: <code class="code docutils literal notranslate"><span class="pre">MODULE</span> <span class="pre">OpenMM_Types</span></code> and <code class="code docutils literal notranslate"><span class="pre">MODULE</span> <span class="pre">OpenMM</span></code>; however,
only the <code class="code docutils literal notranslate"><span class="pre">OpenMM</span></code> module will appear in user programs (it references
the other module internally). The modules contain declarations for all the
OpenMM Fortran interface subroutines, related types, and parameters (constants).
Note that if you follow our suggested structure, you will not need to
<code class="code docutils literal notranslate"><span class="pre">use</span></code> the <code class="code docutils literal notranslate"><span class="pre">OpenMM</span></code> module in your <code class="code docutils literal notranslate"><span class="pre">main()</span></code>
compilation unit but can instead use it only in a local file that you write to
provide a simple interface to your existing code (see Chapter <a class="reference internal" href="03_tutorials.html#openmm-tutorials"><span class="std std-numref">9</span></a>).</p>
</section>
<section id="mapping-from-the-c-api-to-the-fortran-api">
<h3><span class="section-number">11.2.2. </span>Mapping from the C++ API to the Fortran API<a class="headerlink" href="#mapping-from-the-c-api-to-the-fortran-api" title="Permalink to this heading">¶</a></h3>
<p>The automated generator of the Fortran “wrappers” follows the translation
strategy shown in Table 11-3. The idea is that if you see the construct on the
left in the C++ API documentation, you should interpret it as the corresponding
construct on the right in Fortran. Please look at the supplied example programs
to see how this is done in practice. Note that all subroutines and modules are
declared with “<code class="code docutils literal notranslate"><span class="pre">implicit</span> <span class="pre">none</span></code>”, meaning that the type of every symbol
is declared explicitly and should not be inferred from the first letter of the
symbol name.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Construct</p></th>
<th class="head"><p>C++ API declaration</p></th>
<th class="head"><p>Equivalent in Fortran API</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>namespace</p></td>
<td><p>OpenMM::</p></td>
<td><p>OpenMM_ (prefix)</p></td>
</tr>
<tr class="row-odd"><td><p>class</p></td>
<td><p>class OpenMM::ClassName</p></td>
<td><p>type (OpenMM_ClassName)</p></td>
</tr>
<tr class="row-even"><td><p>constant</p></td>
<td><p>OpenMM::RadiansPerDeg</p></td>
<td><p>parameter (OpenMM_RadiansPerDeg)</p></td>
</tr>
<tr class="row-odd"><td><p>class enum</p></td>
<td><p>OpenMM::State::Positions</p></td>
<td><p>parameter (OpenMM_State_Positions)</p></td>
</tr>
<tr class="row-even"><td><p>constructor</p></td>
<td><p>new OpenMM::ClassName()</p></td>
<td><div class="line-block">
<div class="line">type (OpenMM_ClassName) thing</div>
<div class="line">call OpenMM_ClassName_create(thing)</div>
<div class="line">(additional constructors are _create_2(), etc.)</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>destructor</p></td>
<td><div class="line-block">
<div class="line">OpenMM::ClassName* thing;</div>
<div class="line">delete thing;</div>
</div>
</td>
<td><div class="line-block">
<div class="line">type (OpenMM_ClassName) thing</div>
<div class="line">call OpenMM_ClassName_destroy(thing)</div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>class method</p></td>
<td><div class="line-block">
<div class="line">OpenMM::ClassName* thing;</div>
<div class="line">thing-&gt;method(args*)</div>
</div>
</td>
<td><div class="line-block">
<div class="line">type (OpenMM_ClassName) thing</div>
<div class="line">call OpenMM_ClassName_method(thing, args)</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>Boolean (type &amp; constants)</p></td>
<td><div class="line-block">
<div class="line">bool</div>
<div class="line">true</div>
<div class="line">false</div>
</div>
</td>
<td><div class="line-block">
<div class="line">integer*4</div>
<div class="line">parameter (OpenMM_True=1)</div>
<div class="line">parameter (OpenMM_False=0)</div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>string</p></td>
<td><p>std::string</p></td>
<td><p>character(*)</p></td>
</tr>
<tr class="row-odd"><td><p>3-vector</p></td>
<td><p>OpenMM::Vec3</p></td>
<td><p>real*8 vec(3)</p></td>
</tr>
<tr class="row-even"><td><p>arrays</p></td>
<td><p>std::vector&lt;std::string&gt;
std::vector&lt;double&gt;
std::vector&lt;Vec3&gt;
std::vector&lt;std::pair&lt;int,int&gt;&gt;
std::map&lt;std::string, double&gt;</p></td>
<td><div class="line-block">
<div class="line">type (OpenMM_StringArray)</div>
<div class="line">type (OpenMM_DoubleArray)</div>
<div class="line">type (OpenMM_Vec3Array)</div>
<div class="line">type (OpenMM_BondArray)</div>
<div class="line">type (OpenMM_ParameterArray)</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>Table 11-3: Default mapping of objects from the C++ API to the Fortran API</p>
<p>Because there are no C++ API equivalents to the array types, they are described
in detail below.</p>
</section>
<section id="id2">
<h3><span class="section-number">11.2.3. </span>OpenMM_Vec3 helper type<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<p>Unlike the other OpenMM objects which are opaque and manipulated via pointers,
the Fortran API uses an ordinary <code class="code docutils literal notranslate"><span class="pre">real*8(3)</span></code> array in
place of the <code class="code docutils literal notranslate"><span class="pre">OpenMM::Vec3</span></code> type.
You can work directly with the individual elements of this type from your
Fortran program if you want. For convenience, a <code class="code docutils literal notranslate"><span class="pre">scale()</span></code> function is
provided that creates a new Vec3 from an old one and a scale factor:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">OpenMM_Vec3_scale</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="w"> </span><span class="nb">scale</span><span class="p">,</span><span class="w"> </span><span class="k">result</span><span class="p">)</span>
<span class="kt">real</span><span class="o">*</span><span class="mi">8</span><span class="w"> </span><span class="n">vec</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="nb">scale</span><span class="p">,</span><span class="w"> </span><span class="k">result</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>No explicit <code class="code docutils literal notranslate"><span class="pre">type</span></code><code class="code docutils literal notranslate"><span class="pre">(OpenMM_Vec3)</span></code> is provided in the Fortran
API since it is not needed.</p>
</section>
<section id="id3">
<h3><span class="section-number">11.2.4. </span>Array helper types<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h3>
<p>C++ has built-in container types <code class="code docutils literal notranslate"><span class="pre">std::vector</span></code> and <code class="code docutils literal notranslate"><span class="pre">std::map</span></code>
which OpenMM uses to manipulate arrays of objects. These don’t have direct
equivalents in Fortran, so we supply special array types for each kind of object
for which OpenMM creates containers. These are: string, double, Vec3, bond, and
parameter map. See Table 11-4 for the names of the Fortran types for each of
these object arrays. Each of the array types provides these functions (prefixed
by <code class="code docutils literal notranslate"><span class="pre">OpenMM_</span></code> and the actual <em>Thing</em> name), with the syntax shown
conceptually since it differs slightly for each kind of object.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Operation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="line-block">
<div class="line">subroutine create(array,size)</div>
<div class="line">type (OpenMM_<em>Thing</em>Array) array</div>
<div class="line">integer*4 size</div>
</div>
</td>
<td><p>Create a heap-allocated array of <em>Things</em>, with space pre-allocated to hold <code class="code docutils literal notranslate"><span class="pre">size</span></code> of them.
You can start at <code class="code docutils literal notranslate"><span class="pre">size</span></code>==0 if you want since these arrays are dynamically resizeable.</p></td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line">subroutine destroy(array)</div>
<div class="line">type (OpenMM_<em>Thing</em>Array) array</div>
</div>
</td>
<td><p>Free the heap space that is currently in use for the passed-in array of <em>Things</em>.</p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">function getSize(array)</div>
<div class="line">type (OpenMM_<em>Thing</em>Array) array</div>
<div class="line">integer*4 size</div>
</div>
</td>
<td><p>Return the current number of <em>Things</em> in this array. This means you can <code class="code docutils literal notranslate"><span class="pre">get()</span></code> and
<code class="code docutils literal notranslate"><span class="pre">set()</span></code> elements up to <code class="code docutils literal notranslate"><span class="pre">getSize()</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line">subroutine resize(array,size)</div>
<div class="line">type (OpenMM_<em>Thing</em>Array) array</div>
<div class="line">integer*4 size</div>
</div>
</td>
<td><p>Change the size of this array to the indicated value which may be smaller or larger than the
current size. Existing elements remain in their same locations as long as they still fit.</p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">subroutine append(array,elt)</div>
<div class="line">type (OpenMM_<em>Thing</em>Array) array</div>
<div class="line"><em>Thing</em> elt</div>
</div>
</td>
<td><p>Add a <em>Thing</em> to the end of the array, increasing the array size by one. The precise syntax depends
on the actual type of <em>Thing</em>; see below.</p></td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line">subroutine set(array,index,elt)</div>
<div class="line">type (OpenMM_<em>Thing</em>Array) array</div>
<div class="line">integer*4 size</div>
<div class="line"><em>Thing</em> elt</div>
</div>
</td>
<td><p>Store a copy of <code class="code docutils literal notranslate"><span class="pre">elt</span></code> in the indicated element of the array (indexed from 1). The array must
be of length at least <code class="code docutils literal notranslate"><span class="pre">index</span></code>; you can’t grow the array with this function.</p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">subroutine get(array,index,elt)</div>
<div class="line">type (OpenMM_<em>Thing</em>Array) array</div>
<div class="line">integer*4 size</div>
<div class="line"><em>Thing</em> elt</div>
</div>
</td>
<td><p>Retrieve a particular element from the array (indexed from 1).  Some <em>Things</em> require more than one
argument to return.</p></td>
</tr>
</tbody>
</table>
<p>Table 11-4: Generic description of array helper types</p>
<p>Here are the exact declarations with deviations from the generic description
noted, for each of the array types.</p>
<section id="id4">
<h4>OpenMM_DoubleArray<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h4>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">OpenMM_DoubleArray_create</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="w">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="n">size</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_DoubleArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">subroutine </span><span class="n">OpenMM_DoubleArray_destroy</span><span class="p">(</span><span class="k">array</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_DoubleArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">function </span><span class="n">OpenMM_DoubleArray_getSize</span><span class="p">(</span><span class="k">array</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_DoubleArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="n">OpenMM_DoubleArray_getSize</span>
<span class="k">subroutine </span><span class="n">OpenMM_DoubleArray_resize</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_DoubleArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="n">size</span>
<span class="k">subroutine </span><span class="n">OpenMM_DoubleArray_append</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="k">value</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_DoubleArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">real</span><span class="o">*</span><span class="mi">8</span><span class="w"> </span><span class="k">value</span>
<span class="k">subroutine </span><span class="n">OpenMM_DoubleArray_set</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="nb">index</span><span class="p">,</span><span class="w"> </span><span class="k">value</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_DoubleArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="nb">index</span>
<span class="nb">    </span><span class="kt">real</span><span class="o">*</span><span class="mi">8</span><span class="w"> </span><span class="k">value</span>
<span class="k">subroutine </span><span class="n">OpenMM_DoubleArray_get</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="nb">index</span><span class="p">,</span><span class="w"> </span><span class="k">value</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_DoubleArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="nb">index</span>
<span class="nb">    </span><span class="kt">real</span><span class="o">*</span><span class="mi">8</span><span class="w"> </span><span class="k">value</span>
</pre></div>
</div>
</section>
<section id="id5">
<h4>OpenMM_StringArray<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h4>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">OpenMM_StringArray_create</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="w">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="n">size</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_StringArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">subroutine </span><span class="n">OpenMM_StringArray_destroy</span><span class="p">(</span><span class="k">array</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_StringArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">function </span><span class="n">OpenMM_StringArray_getSize</span><span class="p">(</span><span class="k">array</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_StringArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="n">OpenMM_StringArray_getSize</span>
<span class="k">subroutine </span><span class="n">OpenMM_StringArray_resize</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_StringArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="n">size</span>
<span class="k">subroutine </span><span class="n">OpenMM_StringArray_append</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_StringArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">str</span>
<span class="k">subroutine </span><span class="n">OpenMM_StringArray_set</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="nb">index</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_StringArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="nb">index</span>
<span class="nb">    </span><span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">str</span>
<span class="k">subroutine </span><span class="n">OpenMM_StringArray_get</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="nb">index</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_StringArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="nb">index</span>
<span class="nb">    </span><span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="n">str</span>
</pre></div>
</div>
</section>
<section id="id6">
<h4>OpenMM_Vec3Array<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h4>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">OpenMM_Vec3Array_create</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="w">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="n">size</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_Vec3Array</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">subroutine </span><span class="n">OpenMM_Vec3Array_destroy</span><span class="p">(</span><span class="k">array</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_Vec3Array</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">function </span><span class="n">OpenMM_Vec3Array_getSize</span><span class="p">(</span><span class="k">array</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_Vec3Array</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="n">OpenMM_Vec3Array_getSize</span>
<span class="k">subroutine </span><span class="n">OpenMM_Vec3Array_resize</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_Vec3Array</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="n">size</span>
<span class="k">subroutine </span><span class="n">OpenMM_Vec3Array_append</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="n">vec</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_Vec3Array</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">real</span><span class="o">*</span><span class="mi">8</span><span class="w"> </span><span class="n">vec</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">subroutine </span><span class="n">OpenMM_Vec3Array_set</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="nb">index</span><span class="p">,</span><span class="w"> </span><span class="n">vec</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_Vec3Array</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="nb">index</span>
<span class="nb">    </span><span class="kt">real</span><span class="o">*</span><span class="mi">8</span><span class="w"> </span><span class="n">vec</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">subroutine </span><span class="n">OpenMM_Vec3Array_get</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="nb">index</span><span class="p">,</span><span class="w"> </span><span class="n">vec</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_Vec3Array</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="nb">index</span>
<span class="nb">    </span><span class="kt">real</span><span class="o">*</span><span class="mi">8</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id7">
<h4>OpenMM_BondArray<a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h4>
<p>Note that bonds are specified by pairs of integers (the atom indices). The
<code class="code docutils literal notranslate"><span class="pre">get()</span></code> method returns those in a pair of final arguments rather than as
its functional return.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">OpenMM_BondArray_create</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="w">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="n">size</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_BondArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">subroutine </span><span class="n">OpenMM_BondArray_destroy</span><span class="p">(</span><span class="k">array</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_BondArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">function </span><span class="n">OpenMM_BondArray_getSize</span><span class="p">(</span><span class="k">array</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_BondArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="n">OpenMM_BondArray_getSize</span>
<span class="k">subroutine </span><span class="n">OpenMM_BondArray_resize</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_BondArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="n">size</span>
<span class="k">subroutine </span><span class="n">OpenMM_BondArray_append</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="n">particle1</span><span class="p">,</span><span class="w"> </span><span class="n">particle2</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_BondArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="n">particle1</span><span class="p">,</span><span class="w"> </span><span class="n">particle2</span>
<span class="k">subroutine </span><span class="n">OpenMM_BondArray_set</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="nb">index</span><span class="p">,</span><span class="w"> </span><span class="n">particle1</span><span class="p">,</span><span class="w"> </span><span class="n">particle2</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_BondArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="nb">index</span><span class="p">,</span><span class="w"> </span><span class="n">particle1</span><span class="p">,</span><span class="w"> </span><span class="n">particle2</span>
<span class="k">subroutine </span><span class="n">OpenMM_BondArray_get</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="nb">index</span><span class="p">,</span><span class="w"> </span><span class="n">particle1</span><span class="p">,</span><span class="w"> </span><span class="n">particle2</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_BondArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="nb">index</span><span class="p">,</span><span class="w"> </span><span class="n">particle1</span><span class="p">,</span><span class="w"> </span><span class="n">particle2</span>
</pre></div>
</div>
</section>
<section id="id8">
<h4>OpenMM_ParameterArray<a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h4>
<p>OpenMM returns references to internal <code class="code docutils literal notranslate"><span class="pre">ParameterArrays</span></code> but does not
support user-created <code class="code docutils literal notranslate"><span class="pre">ParameterArrays</span></code>, so only the <code class="code docutils literal notranslate"><span class="pre">get()</span></code>
and <code class="code docutils literal notranslate"><span class="pre">getSize()</span></code> functions are available. Also, note that since this is
actually a map rather than an array, the “index” is the <em>name</em> of the
parameter rather than its ordinal.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">function </span><span class="n">OpenMM_ParameterArray_getSize</span><span class="p">(</span><span class="k">array</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_ParameterArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">integer</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="n">OpenMM_ParameterArray_getSize</span>
<span class="k">subroutine </span><span class="n">OpenMM_ParameterArray_get</span><span class="p">(</span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">param</span><span class="p">)</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">OpenMM_ParameterArray</span><span class="p">)</span><span class="w"> </span><span class="k">array</span>
<span class="k">    </span><span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">name</span>
<span class="w">    </span><span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">param</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="python-api">
<h2><span class="section-number">11.3. </span>Python API<a class="headerlink" href="#python-api" title="Permalink to this heading">¶</a></h2>
<section id="mapping-from-the-c-api-to-the-python-api">
<h3><span class="section-number">11.3.1. </span>Mapping from the C++ API to the Python API<a class="headerlink" href="#mapping-from-the-c-api-to-the-python-api" title="Permalink to this heading">¶</a></h3>
<p>The Python API follows the C++ API as closely as possible. There are three
notable differences:</p>
<ol class="arabic">
<li><p>The <code class="code docutils literal notranslate"><span class="pre">getState()</span></code> method in the <code class="code docutils literal notranslate"><span class="pre">Context</span></code> class takes
Pythonic-type arguments to indicate which state variables should be made
available.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>myContext.getState(getEnergy=True, getForce=False, …)
</pre></div>
</div>
</li>
<li><p>Wherever the C++ API uses references to return multiple values from a method,
the Python API returns a tuple.  For example, in C++ you would query a
HarmonicBondForce for a bond’s parameters as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">particle1</span><span class="p">,</span> <span class="n">particle2</span><span class="p">;</span>
<span class="n">double</span> <span class="n">length</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
<span class="n">f</span><span class="o">.</span><span class="n">getBondParameters</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">particle1</span><span class="p">,</span> <span class="n">particle2</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
</pre></div>
</div>
<p>In Python, the equivalent code is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">particle1</span><span class="p">,</span> <span class="n">particle2</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">getBondParameters</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Unlike C++, the Python API accepts and returns quantities with units attached
to most values (see Section <a class="reference internal" href="#units-and-dimensional-analysis"><span class="std std-numref">11.3.3</span></a> below for
details).  In short, this means that while values in C++ have <em>implicit</em>
units, the Python API returns objects that have values and <em>explicit</em> units.</p></li>
</ol>
</section>
<section id="mechanics-of-using-the-python-api">
<h3><span class="section-number">11.3.2. </span>Mechanics of using the Python API<a class="headerlink" href="#mechanics-of-using-the-python-api" title="Permalink to this heading">¶</a></h3>
<p>When using the Python API, be sure to include the GPU support
libraries in your library path, just as you would for a C++ application.  This
is set with the <code class="code docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code> environment variable on Linux,
<code class="code docutils literal notranslate"><span class="pre">DYLD_LIBRARY_PATH</span></code> on Mac, or <code class="code docutils literal notranslate"><span class="pre">PATH</span></code> on Windows.  See
Chapter <a class="reference internal" href="../application/01_getting_started.html#installing-openmm"><span class="std std-numref">2.2</span></a> for details.</p>
<p>The Python API is contained in the openmm package, while the units code is
contained in the openmm.units package.  (The application layer, described in the
Application Guide, is contained in the openmm.app package.)  A program
using it will therefore typically begin</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">openmm</span> <span class="k">as</span> <span class="nn">mm</span>
<span class="kn">import</span> <span class="nn">openmm.unit</span> <span class="k">as</span> <span class="nn">unit</span>
</pre></div>
</div>
<p>Creating and using OpenMM objects is then done exactly as in C++:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">system</span> <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">System</span><span class="p">()</span>
<span class="n">nb</span> <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">NonbondedForce</span><span class="p">()</span>
<span class="n">nb</span><span class="o">.</span><span class="n">setNonbondedMethod</span><span class="p">(</span><span class="n">mm</span><span class="o">.</span><span class="n">NonbondedForce</span><span class="o">.</span><span class="n">CutoffNonPeriodic</span><span class="p">)</span>
<span class="n">nb</span><span class="o">.</span><span class="n">setCutoffDistance</span><span class="p">(</span><span class="mf">1.2</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">nanometer</span><span class="p">)</span>
<span class="n">system</span><span class="o">.</span><span class="n">addForce</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that when setting the cutoff distance, we explicitly specify that it is in
nanometers.  We could just as easily specify it in different units:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nb</span><span class="o">.</span><span class="n">setCutoffDistance</span><span class="p">(</span><span class="mi">12</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>
</pre></div>
</div>
<p>The use of units in OpenMM is discussed in the next section.</p>
</section>
<section id="units-and-dimensional-analysis">
<span id="id9"></span><h3><span class="section-number">11.3.3. </span>Units and dimensional analysis<a class="headerlink" href="#units-and-dimensional-analysis" title="Permalink to this heading">¶</a></h3>
<section id="why-does-the-python-api-include-units">
<h4>Why does the Python API include units?<a class="headerlink" href="#why-does-the-python-api-include-units" title="Permalink to this heading">¶</a></h4>
<p>The C++ API for OpenMM uses an <em>implicit</em> set of units for physical
quantities such as lengths, masses, energies, etc.  These units are based on
daltons, nanometers, and picoseconds for the mass, length, and time dimensions,
respectively.  When using the C++ API, it is very important to ensure that
quantities being manipulated are always expressed in terms of these units.  For
example, if you read in a distance in Angstroms, you must multiply that distance
by a conversion factor to turn it into nanometers before using it in the C++
API.  Such conversions can be a source of tedium and errors.  This is true in
many areas of scientific programming.  Units confusion was blamed for the loss
of the Mars Climate Orbiter spacecraft in 1999, at a cost of more than $100
million.  Units were introduced in the Python API to minimize the chance of such
errors.</p>
<p>The Python API addresses the potential problem of conversion errors by using
quantities with explicit units.  If a particular distance is expressed in
Angstroms, the Python API will know that it is in Angstroms.  When the time
comes to call the C++ API, it will understand that the quantity must be
converted to nanometers.  You, the programmer, must declare upfront that the
quantity is in Angstrom units, and the API will take care of the details from
then on.  Using explicit units is a bit like brushing your teeth: it requires
some effort upfront, but it probably saves you trouble in the long run.</p>
</section>
<section id="quantities-units-and-dimensions">
<h4>Quantities, units, and dimensions<a class="headerlink" href="#quantities-units-and-dimensions" title="Permalink to this heading">¶</a></h4>
<p>The explicit unit system is based on three concepts: Dimensions, Units, and
Quantities.</p>
<p>Dimensions are measurable physical concepts such as mass, length, time, and
energy.  Energy is actually a composite dimension based on mass, length, and
time.</p>
<p>A Unit defines a linear scale used to measure amounts of a particular physical
Dimension.  Examples of units include meters, seconds, joules, inches, and
grams.</p>
<p>A Quantity is a specific amount of a physical Dimension.  An example of a
quantity is “0.63 kilograms”.  A Quantity is expressed as a combination of a
value (e.g., 0.63), and a Unit (e.g., kilogram).  The same Quantity can be
expressed in different Units.</p>
<p>The set of BaseDimensions defined in the openmm.unit module includes:</p>
<ul class="simple">
<li><p>mass</p></li>
<li><p>length</p></li>
<li><p>time</p></li>
<li><p>temperature</p></li>
<li><p>amount</p></li>
<li><p>charge</p></li>
<li><p>luminous intensity</p></li>
</ul>
<p>These are not precisely the same list of base dimensions used in the SI unit
system.  SI defines “current” (charge per time) as a base unit, while openmm.unit
uses “charge”.  And openmm.unit treats angle as a dimension, even though angle
quantities are often considered dimensionless.  In this case, we choose to err
on the side of explicitness, particularly because interconversion of degrees and
radians is a frequent source of unit headaches.</p>
</section>
<section id="units-examples">
<h4>Units examples<a class="headerlink" href="#units-examples" title="Permalink to this heading">¶</a></h4>
<p>Many common units are defined in the openmm.unit module.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">openmm.unit</span> <span class="kn">import</span> <span class="n">nanometer</span><span class="p">,</span> <span class="n">angstrom</span><span class="p">,</span> <span class="n">dalton</span>
</pre></div>
</div>
<p>Sometimes you don’t want to type the full unit name every time, so you can
assign it a shorter name using the <code class="code docutils literal notranslate"><span class="pre">as</span></code> functionality:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">openmm.unit</span> <span class="kn">import</span> <span class="n">nanometer</span> <span class="k">as</span> <span class="n">nm</span>
</pre></div>
</div>
<p>New quantities can be created from a value and a unit.  You can use either the
multiply operator (‘*’) or the explicit Quantity constructor:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">simk.unit</span> <span class="kn">import</span> <span class="n">nanometer</span><span class="p">,</span> <span class="n">Quantity</span>
<span class="c1"># construct a Quantity using the multiply operator</span>
<span class="n">bond_length</span> <span class="o">=</span> <span class="mf">1.53</span> <span class="o">*</span> <span class="n">nanometer</span>
<span class="c1"># equivalently using the explicit Quantity constructor</span>
<span class="n">bond_length</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="mf">1.53</span><span class="p">,</span> <span class="n">nanometer</span><span class="p">)</span>
<span class="c1"># or more verbosely</span>
<span class="n">bond_length</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mf">1.53</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">nanometer</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="arithmetic-with-units">
<h4>Arithmetic with units<a class="headerlink" href="#arithmetic-with-units" title="Permalink to this heading">¶</a></h4>
<p>Addition and subtraction of quantities is only permitted between quantities that
share the same dimension.  It makes no sense to add a mass to a distance.  If
you attempt to add or subtract two quantities with different dimensions, an
exception will be raised.  This is a good thing; it helps you avoid errors.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mf">5.0</span><span class="o">*</span><span class="n">dalton</span> <span class="o">+</span> <span class="mf">4.3</span><span class="o">*</span><span class="n">nanometer</span><span class="p">;</span> <span class="c1"># error</span>
</pre></div>
</div>
<p>Addition or subtraction of quantities with the same dimension, but different
units, is fine, and results in a new quantity created using the correct
conversion factor between the units used.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mf">1.3</span><span class="o">*</span><span class="n">nanometer</span> <span class="o">+</span> <span class="mf">5.6</span><span class="o">*</span><span class="n">angstrom</span><span class="p">;</span> <span class="c1"># OK, result in nanometers</span>
</pre></div>
</div>
<p>Quantities can be added and subtracted.  Naked Units cannot.</p>
<p>Multiplying or dividing two quantities creates a new quantity with a composite
dimension.  For example, dividing a distance by a time results in a velocity.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">openmm.unit</span> <span class="kn">import</span> <span class="n">kilogram</span><span class="p">,</span> <span class="n">meter</span><span class="p">,</span> <span class="n">second</span>
<span class="n">a</span> <span class="o">=</span> <span class="mf">9.8</span> <span class="o">*</span> <span class="n">meter</span> <span class="o">/</span> <span class="n">second</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span> <span class="c1"># acceleration</span>
<span class="n">m</span> <span class="o">=</span> <span class="mf">0.36</span> <span class="o">*</span> <span class="n">kilogram</span><span class="p">;</span> <span class="c1"># mass</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">a</span><span class="p">;</span> <span class="c1"># force in kg*m/s**2::</span>
</pre></div>
</div>
<p>Multiplication or division of two Units results in a composite Unit.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mps</span> <span class="o">=</span> <span class="n">meter</span> <span class="o">/</span> <span class="n">second</span>
</pre></div>
</div>
<p>Unlike amount (moles), angle (radians) is arguably dimensionless.  But openmm.unit
treats angle as another dimension.   Use the trigonometric functions from the
openmm.unit module (not those from the Python math module!) when dealing with
Units and Quantities.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">openmm.unit</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">acos</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="mf">90.0</span><span class="o">*</span><span class="n">degrees</span><span class="p">)</span>
<span class="n">angle</span> <span class="o">=</span> <span class="n">acos</span><span class="p">(</span><span class="mf">0.68</span><span class="p">);</span> <span class="c1"># returns an angle quantity (in radians)</span>
</pre></div>
</div>
<p>The method <code class="code docutils literal notranslate"><span class="pre">pow()</span></code> is a built-in Python method that works with
Quantities and Units.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">area</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="n">meter</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1"># or, equivalently</span>
<span class="n">area</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="n">meter</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="c1"># or</span>
<span class="n">area</span> <span class="o">=</span> <span class="mf">9.0</span><span class="o">*</span><span class="p">(</span><span class="n">meter</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The method <code class="code docutils literal notranslate"><span class="pre">sqrt()</span></code> is not as built-in as <code class="code docutils literal notranslate"><span class="pre">pow()</span></code>.  Do not
use the Python <code class="code docutils literal notranslate"><span class="pre">math.sqrt()</span></code> method with Units and Quantities.  Use
the <code class="code docutils literal notranslate"><span class="pre">openmm.unit.sqrt()</span></code> method instead:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">openmm.unit</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="n">side_length</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">meter</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="atomic-scale-mass-and-energy-units-are-per-amount">
<h4>Atomic scale mass and energy units are “per amount”<a class="headerlink" href="#atomic-scale-mass-and-energy-units-are-per-amount" title="Permalink to this heading">¶</a></h4>
<p>Mass and energy units at the atomic scale are specified “per amount” in the
openmm.unit module.  Amount (mole) is one of the seven fundamental dimensions in
the SI unit system.   The atomic scale mass unit, dalton, is defined as grams
per mole.  The dimension of dalton is therefore mass/amount, instead of simply
mass.  Similarly, the atomic scale energy unit, kilojoule_per_mole (and
kilocalorie_per_mole) has “per amount” in its dimension.  Be careful to always
use “per amount” mass and energy types at the atomic scale, and your dimensional
analysis should work out properly.</p>
<p>The energy unit kilocalories_per_mole does not have the same Dimension as the
macroscopic energy unit kilocalories.  Molecular scientists sometimes use the
word “kilocalories” when they mean “kilocalories per mole”.  Use “kilocalories
per mole” or”kilojoules per mole” for molecular energies.  Use “kilocalories”
for the metabolic energy content of your lunch.  The energy unit
kilojoule_per_mole happens to go naturally with the units nanometer,
picoseconds, and dalton.  This is because 1 kilojoule/mole happens to be equal
to 1 gram-nanometer<sup>2</sup>/mole-picosecond<sup>2</sup>, and is therefore
consistent with the molecular dynamics unit system used in the C++ OpenMM API.</p>
<p>These “per mole” units are what you should be using for molecular calculations,
as long as you are using SI / cgs / calorie sorts of units.</p>
</section>
<section id="si-prefixes">
<h4>SI prefixes<a class="headerlink" href="#si-prefixes" title="Permalink to this heading">¶</a></h4>
<p>Many units with SI prefixes such as “milligram” (milli) and “kilometer” (kilo)
are provided in the openmm.unit module.  Others can be created by multiplying a
prefix symbol by a non-prefixed unit:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">openmm.unit</span> <span class="kn">import</span> <span class="n">mega</span><span class="p">,</span> <span class="n">kelvin</span>
<span class="n">megakelvin</span> <span class="o">=</span> <span class="n">mega</span> <span class="o">*</span> <span class="n">kelvin</span>
<span class="n">t</span> <span class="o">=</span> <span class="mf">8.3</span> <span class="o">*</span> <span class="n">megakelvin</span>
</pre></div>
</div>
<p>Only grams and meters get all of the SI prefixes (from yotto-(10<sup>-24</sup>)
to yotta-(10<sup>24</sup>)) automatically.</p>
</section>
<section id="converting-to-different-units">
<h4>Converting to different units<a class="headerlink" href="#converting-to-different-units" title="Permalink to this heading">¶</a></h4>
<p>Use the <code class="code docutils literal notranslate"><span class="pre">Quantity.in_units_of()</span></code> method to create a new Quantity with
different units.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">openmm.unit</span> <span class="kn">import</span> <span class="n">nanosecond</span><span class="p">,</span> <span class="n">fortnight</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">175000</span><span class="o">*</span><span class="n">nanosecond</span><span class="p">)</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">fortnight</span><span class="p">)</span>
</pre></div>
</div>
<p>When you want a plain number out of a Quantity, use the <code class="code docutils literal notranslate"><span class="pre">value_in_unit()</span></code> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">openmm.unit</span> <span class="kn">import</span> <span class="n">femtosecond</span><span class="p">,</span> <span class="n">picosecond</span>
<span class="n">t</span> <span class="o">=</span> <span class="mf">5.0</span><span class="o">*</span><span class="n">femtosecond</span>
<span class="n">t_just_a_number</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">picoseconds</span><span class="p">)</span>
</pre></div>
</div>
<p>Using <code class="code docutils literal notranslate"><span class="pre">value_in_unit()</span></code> puts the responsibility for unit analysis back
into your hands, and it should be avoided.  It is sometimes necessary, however,
when you are called upon to use a non-units-aware Python API.</p>
</section>
<section id="lists-tuples-vectors-numpy-arrays-and-units">
<h4>Lists, tuples, vectors, numpy arrays, and Units<a class="headerlink" href="#lists-tuples-vectors-numpy-arrays-and-units" title="Permalink to this heading">¶</a></h4>
<p>Units can be attached to containers of numbers to create a vector quantity.  The
openmm.unit module overloads the <code class="code docutils literal notranslate"><span class="pre">__setitem__</span></code> and
<code class="code docutils literal notranslate"><span class="pre">__getitem__</span></code> methods for these containers to ensure that Quantities go
in and out.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Vec3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">nanometers</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(1, 2, 3) nm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">angstroms</span><span class="p">))</span>
<span class="go">(10.0, 20.0, 30.0) A</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span> <span class="o">*</span> <span class="n">centimeter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
<span class="go">[[1, 2, 3], [4, 5, 6]] cm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s2</span><span class="o">/</span><span class="n">millimeter</span><span class="p">)</span>
<span class="go">[[10.0, 20.0, 30.0], [40.0, 50.0, 60.0]]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="n">centimeter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">[1 2 3] cm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">millimeter</span><span class="p">)</span>
<span class="go">[ 10.  20.  30.]</span>
</pre></div>
</div>
<p>Converting a whole list to different units at once is much faster than
converting each element individually.  For example, consider the following code
that prints out the position of every particle in a State, as measured in
Angstroms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">getPositions</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">angstrom</span><span class="p">))</span>
</pre></div>
</div>
<p>This can be rewritten as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">getPositions</span><span class="p">()</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">angstrom</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>The two versions produce identical results, but the second one will run faster,
and therefore is preferred.</p>
</section>
</section>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="04_platform_specifics.html" title="Previous document"><span class="section-number">10. </span>Platform-Specific Properties</a>
        </li>
        <li>
          <a href="06_integration_examples.html" title="Next document"><span class="section-number">12. </span>Examples of OpenMM Integration</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.png" alt="Logo"/>
    
    <h1 class="logo logo-name">OpenMM User Guide</h1>
    
  </a>
</p>










<script>
    function switchVersion(value) {
        newlink = value + "userguide"
        location.href = newlink;
    }
</script>

<div class="extra-nav-links">
These docs are for <a href="https://github.com/openmm/openmm/tree/c2d2539933259d85365b465b39e6c3113559e016">OpenMM version 8.0.0.dev-c2d2539</a>
</div>
<div class="extra-nav-links">
You can change to a different version:
<select name="version" id="version_selector" onchange="switchVersion(this.value)">
    <option selected disabled>8.0.0.dev-c2d2539</option>
</select>
</div>

<script>
var selector = document.getElementById("version_selector");
// TODO: move hardcoded url to conf.py
fetch("https://sef43.github.io/openmm_docs/versions.json")
    .then((res) => {
      return res.json();
    })
    .then((data) => {
      data.forEach((entry) => {
        version=entry.version
        url=entry.url
        var option = document.createElement("option");
        option.value = url
        option.text = version
        selector.appendChild(option);
      })
    })
</script>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><div class="navigation-scrollbox">
    <div class="nav-toctree">
    <ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">1. Introduction</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../application.html">Part I: The OpenMM Application Layer</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../library.html">Part II: The OpenMM Library</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="01_introduction.html">7. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="02_compiling.html">8. Compiling OpenMM from Source Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="03_tutorials.html">9. OpenMM Tutorials</a></li>
<li class="toctree-l2"><a class="reference internal" href="04_platform_specifics.html">10. Platform-Specific Properties</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">11. Using OpenMM with Software Written in Languages Other than C++</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#c-api">11.1. C API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fortran-95-api">11.2. Fortran 95 API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#python-api">11.3. Python API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="06_integration_examples.html">12. Examples of OpenMM Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="07_testing_validation.html">13. Testing and Validation of OpenMM</a></li>
<li class="toctree-l2"><a class="reference internal" href="08_amoeba_plugin.html">14. AMOEBA Plugin</a></li>
<li class="toctree-l2"><a class="reference internal" href="09_rpmd_plugin.html">15. Ring Polymer Molecular Dynamics (RPMD) Plugin</a></li>
<li class="toctree-l2"><a class="reference internal" href="10_drude_plugin.html">16. Drude Plugin</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../theory.html">Part III: The Theory Behind OpenMM</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zbibliography.html">22. Bibliography</a></li>
</ul>

    </div>
    
    <ul class="extra-nav-links">
        
        <li class="toctree-l1">
            <a href="https://openmm.org">
                OpenMM.org
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="../../developerguide/">
                Developer Guide
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="../../api-python/">
                Python API reference
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="../../api-c++/">
                C++ API reference
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://github.com/openmm">
                GitHub
            </a>
        </li>
        
    </ul>
    
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2008-2017, Stanford University.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 6.1.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../_sources/library/05_languages_not_cpp.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>