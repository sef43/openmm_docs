
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>8. Common Compute &#8212; OpenMM Dev Guide c2d2539933259d85365b465b39e6c3113559e016 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="7. The CUDA Platform" href="07_cuda_platform.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <style> .code {font-family:monospace;} </style>
<style> .caption {text-align:center;} </style><section id="common-compute">
<span id="id1"></span><h1><span class="section-number">8. </span>Common Compute<a class="headerlink" href="#common-compute" title="Permalink to this heading">¶</a></h1>
<p>Common Compute is not a platform, but it shares many elements of one.  It exists
to reduce code duplication between the OpenCL and CUDA platforms.  It allows a
single implementation to be written for most kernels that can be used by both
platforms.</p>
<p>OpenCL and CUDA are very similar to each other.  Their computational models are
nearly identical.  For example, each is based around launching kernels that are
executed in parallel by many threads.  Each of them groups threads into blocks,
with more communication and synchronization permitted between the threads
in a block than between ones in different blocks.  They have very similar memory
hierarchies: high latency global memory, low latency local/shared memory that
can be used for communication between the threads of a block, and local variables
that are visible only to a single thread.</p>
<p>Even their languages for writing kernels are very similar.  Here is an OpenCL
kernel that adds two arrays together, storing the result in a third array.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__kernel</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">addArrays</span><span class="p">(</span><span class="n">__global</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="k">restrict</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>
<span class="w">                        </span><span class="n">__global</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="k">restrict</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                        </span><span class="n">__global</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="k">restrict</span><span class="w"> </span><span class="n">c</span>
<span class="w">                        </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">get_global_size</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="w">        </span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here is the corresponding CUDA kernel.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">addArrays</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">__restrict__</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>
<span class="w">                                       </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">__restrict__</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                       </span><span class="n">_float</span><span class="o">*</span><span class="w"> </span><span class="n">__restrict__</span><span class="w"> </span><span class="n">c</span>
<span class="w">                                       </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
<span class="w">        </span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The difference between them is largely just a mechanical find-and-replace.
After many years of writing and maintaining nearly identical kernels by hand,
it finally occurred to us that the translation could be done automatically by
the compiler.  Simply by defining a few preprocessor macros, the following
kernel can be compiled equally well either as OpenCL or as CUDA.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">KERNEL</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">addArrays</span><span class="p">(</span><span class="n">GLOBAL</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">RESTRICT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>
<span class="w">                      </span><span class="n">GLOBAL</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">RESTRICT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                      </span><span class="n">GLOBAL</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">RESTRICT</span><span class="w"> </span><span class="n">c</span>
<span class="w">                      </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GLOBAL_ID</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">GLOBAL_SIZE</span><span class="p">)</span>
<span class="w">        </span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="writing-device-code">
<h2><span class="section-number">8.1. </span>Writing Device Code<a class="headerlink" href="#writing-device-code" title="Permalink to this heading">¶</a></h2>
<p>When compiling kernels with the Common Compute API, the following macros are
defined.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Macro</p></th>
<th class="head"><p>OpenCL Definition</p></th>
<th class="head"><p>CUDA Definition</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="code">KERNEL</span></p></td>
<td><p><span class="code">__kernel</span></p></td>
<td><p><span class="code">extern “C” __global__</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="code">DEVICE</span></p></td>
<td></td>
<td><p><span class="code">__device__</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="code">LOCAL</span></p></td>
<td><p><span class="code">__local</span></p></td>
<td><p><span class="code">__shared__</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="code">LOCAL_ARG</span></p></td>
<td><p><span class="code">__local</span></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="code">GLOBAL</span></p></td>
<td><p><span class="code">__global</span></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="code">RESTRICT</span></p></td>
<td><p><span class="code">restrict</span></p></td>
<td><p><span class="code">__restrict__</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="code">LOCAL_ID</span></p></td>
<td><p><span class="code">get_local_id(0)</span></p></td>
<td><p><span class="code">threadIdx.x</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="code">LOCAL_SIZE</span></p></td>
<td><p><span class="code">get_local_size(0)</span></p></td>
<td><p><span class="code">blockDim.x</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="code">GLOBAL_ID</span></p></td>
<td><p><span class="code">get_global_id(0)</span></p></td>
<td><p><span class="code">(blockIdx.x*blockDim.x+threadIdx.x)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="code">GLOBAL_SIZE</span></p></td>
<td><p><span class="code">get_global_size(0)</span></p></td>
<td><p><span class="code">(blockDim.x*gridDim.x)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="code">GROUP_ID</span></p></td>
<td><p><span class="code">get_group_id(0)</span></p></td>
<td><p><span class="code">blockIdx.x</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="code">NUM_GROUPS</span></p></td>
<td><p><span class="code">get_num_groups(0)</span></p></td>
<td><p><span class="code">gridDim.x</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="code">SYNC_THREADS</span></p></td>
<td><p><span class="code">barrier(CLK_LOCAL_MEM_FENCE+CLK_GLOBAL_MEM_FENCE);</span></p></td>
<td><p><span class="code">__syncthreads();</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="code">SYNC_WARPS</span></p></td>
<td><div class="line-block">
<div class="line">if SIMT width &gt;= 32:</div>
<div class="line"><span class="code">mem_fence(CLK_LOCAL_MEM_FENCE)</span></div>
<div class="line">otherwise:</div>
<div class="line"><span class="code">barrier(CLK_LOCAL_MEM_FENCE)</span></div>
</div>
</td>
<td><div class="line-block">
<div class="line">if compute capability &gt;= 7.0:</div>
<div class="line"><span class="code">__syncwarp();</span></div>
<div class="line">otherwise empty</div>
</div>
</td>
</tr>
<tr class="row-even"><td><p><span class="code">MEM_FENCE</span></p></td>
<td><p><span class="code">mem_fence(CLK_LOCAL_MEM_FENCE+CLK_GLOBAL_MEM_FENCE);</span></p></td>
<td><p><span class="code">__threadfence_block();</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="code">ATOMIC_ADD(dest, value)</span></p></td>
<td><p><span class="code">atom_add(dest, value)</span></p></td>
<td><p><span class="code">atomicAdd(dest, value)</span></p></td>
</tr>
</tbody>
</table>
<p>A few other symbols may or may not be defined based on the device you are running on:
<span class="code">SUPPORTS_DOUBLE_PRECISION</span> and <span class="code">SUPPORTS_64_BIT_ATOMICS</span>.  You
can use <span class="code">#ifdef</span> blocks with these symbols to conditionally compile code
based on the features supported by the device.  In addition, the CUDA compiler
defines the symbol <span class="code">__CUDA_ARCH__</span>, so you can check for this symbol if
you want to have different code blocks for CUDA and OpenCL.</p>
<p>Both OpenCL and CUDA define vector types like <span class="code">int2</span> and <span class="code">float4</span>.
The types they support are different but overlapping.  When writing common code,
use only the vector types that are supported by both OpenCL and CUDA: 2, 3, and 4
element vectors of type <span class="code">short</span>, <span class="code">int</span>, <span class="code">float</span>, and
<span class="code">double</span>.</p>
<p>CUDA uses functions to construct vector values, such as <span class="code">make_float2(x, y)</span>.
OpenCL instead uses a typecast like syntax: <span class="code">(float2) (x, y)</span>.  In common
code, use the CUDA style <span class="code">make_</span> functions.  OpenMM provides definitions
of these functions when compiling as OpenCL.</p>
<p>In CUDA, vector types are simply data structures.  You can access their elements,
but not do much more with them.  In contrast, OpenCL’s vectors are mathematical
types.  All standard math operators are defined for them, as well as geometrical
functions like <span class="code">dot()</span> and <span class="code">cross()</span>.  When compiling kernels as
CUDA, OpenMM provides definitions of these operators and functions.</p>
<p>OpenCL also supports “swizzle” notation for vectors.  For example, if <span class="code">f</span>
is a <span class="code">float4</span> you can construct a vector of its first three elements
by writing <span class="code">f.xyz</span>, or you can swap its first two elements by writing
<span class="code">f.xy = f.yx</span>.  Unfortunately, there is no practical way to support this
in CUDA, so swizzle notation cannot be used in common code.  Because stripping
the final element from a four component vector is such a common operation, OpenMM
provides a special function for doing it: <span class="code">trimTo3(f)</span> is a vector of its
first three elements.</p>
<p>64 bit integers are another data type that needs special handling.  Both OpenCL
and CUDA support them, but they use different names for them: <span class="code">long</span> in OpenCL,
<span class="code">long long</span> in CUDA.  To work around this inconsistency, OpenMM provides
the typedefs <span class="code">mm_long</span> and <span class="code">mm_ulong</span> for signed and unsigned 64 bit
integers in device code.</p>
</section>
<section id="writing-host-code">
<h2><span class="section-number">8.2. </span>Writing Host Code<a class="headerlink" href="#writing-host-code" title="Permalink to this heading">¶</a></h2>
<p>Host code for Common Compute is very similar to host code for OpenCL or CUDA.
In fact, most of the classes provided by the OpenCL and CUDA platforms are
subclasses of Common Compute classes.  For example, OpenCLContext and
CudaContext are both subclasses of ComputeContext.  When writing common code,
each KernelImpl should expect a ComputeContext to be passed to its constructor.
By using the common API provided by that abstract class, it can be used for
either OpenCL or CUDA just based on the particular context passed to it at
runtime.  Similarly, OpenCLNonbondedUtilities and CudaNonbondedUtilities are
subclasses of the abstract NonbondedUtilities class, and so on.</p>
<p>ArrayInterface is an abstract class defining the interface for arrays stored on
the device.  OpenCLArray and CudaArray are both subclasses of it.  To simplify
code that creates and uses arrays, there is also a third subclass called
ComputeArray.  It acts as a wrapper around an OpenCLArray or CudaArray,
automatically creating an array of the appropriate type for the current
platform.  In practice, just follow these rules:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Whenever you need to create an array, make it a ComputeArray.</p></li>
<li><p>Whenever you write a function that expects an array to be passed to it,
declare the type to be ArrayInterface.</p></li>
</ol>
</div></blockquote>
<p>If you do these two things, all differences between platforms will be handled
automatically.</p>
<p>OpenCL and CUDA have quite different APIs for compiling and invoking kernels.
To hide these differences, OpenMM provides a set of abstract classes.  To compile
device code, pass the source code to <span class="code">compileProgram()</span> on the ComputeContext.
This returns a ComputeProgram.  You can then call its <span class="code">createKernel()</span>
method to get a ComputeKernel object, which has methods for setting arguments
and invoking the kernel.</p>
<p>Sometimes you need to refer to vector types in host code, such as to set the
value for a kernel argument or to access the elements of an array.  OpenCL and
CUDA both define types for them, but they have different names, and in any case
you want to avoid using OpenCL-specific or CUDA-specific types in common code.
OpenMM therefore defines types for vectors in host code.  They have the same
names as the corresponding types in device code, only with the prefix <span class="code">mm_</span>,
for example <span class="code">mm_int2</span> and <span class="code">mm_float4</span>.</p>
<p>Three component vectors need special care in this context, because the platforms
define them differently.  In OpenCL, a three component vector is essentially a
four component vector whose last component is ignored.  For example,
<span class="code">sizeof(float3)</span> is 12 in CUDA but 16 in OpenCL.  Within a kernel this
distinction can usually be ignored, but when communicating between host and
device it becomes vitally important.  It is generally best to avoid storing
three component vectors in arrays or passing them as arguments.  There are no
<span class="code">mm_</span> host types defined for three component vectors, because CUDA and
OpenCL would require them to be defined in different ways.</p>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="07_cuda_platform.html" title="Previous document"><span class="section-number">7. </span>The CUDA Platform</a>
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="index.html">
    <img class="logo" src="_static/logo.png" alt="Logo"/>
    
    <h1 class="logo logo-name">OpenMM Dev Guide</h1>
    
  </a>
</p>










<script>
    function switchVersion(value) {
        newlink = value + "developerguide"
        location.href = newlink;
    }
</script>

<div class="extra-nav-links">
These docs are for <a href="https://github.com/openmm/openmm/tree/c2d2539933259d85365b465b39e6c3113559e016">OpenMM version 8.0.0.dev-c2d2539</a>
</div>
<div class="extra-nav-links">
You can change to a different version:
<select name="version" id="version_selector" onchange="switchVersion(this.value)">
    <option selected disabled>8.0.0.dev-c2d2539</option>
</select>
</div>

<script>
var selector = document.getElementById("version_selector");
// TODO: move hardcoded url to conf.py
fetch("https://sef43.github.io/openmm_docs/versions.json")
    .then((res) => {
      return res.json();
    })
    .then((data) => {
      data.forEach((entry) => {
        version=entry.version
        url=entry.url
        var option = document.createElement("option");
        option.value = url
        option.text = version
        selector.appendChild(option);
      })
    })
</script>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><div class="navigation-scrollbox">
    <div class="nav-toctree">
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="01_introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_core_library.html">2. The Core Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_writing_plugins.html">3. Writing Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_reference_platform.html">4. The Reference Platform</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_cpu_platform.html">5. The CPU Platform</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_opencl_platform.html">6. The OpenCL Platform</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_cuda_platform.html">7. The CUDA Platform</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">8. Common Compute</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#writing-device-code">8.1. Writing Device Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#writing-host-code">8.2. Writing Host Code</a></li>
</ul>
</li>
</ul>

    </div>
    
    <ul class="extra-nav-links">
        
        <li class="toctree-l1">
            <a href="https://openmm.org">
                OpenMM.org
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="../userguide/">
                User's Manual
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="../api-python/">
                Python API reference
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="../api-c++/">
                C++ API reference
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://github.com/openmm">
                GitHub
            </a>
        </li>
        
    </ul>
    
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2011-2017, Stanford University.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 6.1.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/08_common_compute.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>